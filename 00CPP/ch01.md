## union

联合（union）是一种节省空间的特殊的类，一个 union 可以有多个数据成员，但是在任意时刻**只有一个数据成员可以有值**。当某个成员被赋值后其他成员变为未定义状态。联合有如下特点：

- 默认访问控制符为 public
- 可以含有构造函数、析构函数
- 不能含有引用类型的成员
- 不能继承自其他类，不能作为基类
- 不能含有虚函数
- 匿名 union 在定义所在作用域可直接访问 union 成员
- 匿名 union 不能包含 protected 成员或 private 成员
- 全局匿名联合必须是静态（static）

## 类的大小计算

- 空类的大小为1。
- 静态数据成员被编译器放在程序的一个global data members中，它是类的一个数据成员，但不影响类的大小。
- 一个类中，虚函数本身、成员函数（包括静态与非静态）和静态数据成员都是不占用类对象的存储空间。
- 对于包含虚函数的类，不管有多少个虚函数，只有一个虚指针,vptr的大小。
- 普通继承，派生类继承了所有基类的函数与成员，要按照字节对齐来计算大小
- 虚函数继承，不管是单继承还是多继承，都是继承了基类的vptr。(32位操作系统4字节，64位操作系统 8字节)！
- 虚继承,继承基类的vptr。

> 1. 计算偏移量从0开始计算；
> 2. 当前元素的偏移从元素自身大小的整数倍开始计算。
> 3. 最后结果一定是结构体中最大基本数据类型的整数倍；

## enum

枚举类型的定义格式为：

```cpp
enum <类型名> {<枚举常量表>};
```

**格式说明：**

- 关键字enum——指明其后的标识符是一个枚举类型的名字。
- 枚举常量表——由枚举常量构成。"枚举常量"或称"枚举成员"，是以标识符形式表示的整型量，表示枚举类型的取值。枚举常量表列出枚举类型的所有取值，各枚举常量之间以"，"间隔，且必须各不相同。取值类型与条件表达式相同。

**应用举例：**

```
enum color_set1 {RED, BLUE, WHITE, BLACK}; // 定义枚举类型color_set1
enum week {Sun, Mon, Tue, Wed, Thu, Fri, Sat}; // 定义枚举类型week

enum fruit_set {apple, orange, banana=1, peach, grape}
//枚举常量apple=0,orange=1, banana=1,peach=2,grape=3。

enum week {Sun=7, Mon=1, Tue, Wed, Thu, Fri, Sat};
//枚举常量Sun,Mon,Tue,Wed,Thu,Fri,Sat的值分别为7、1、2、3、4、5、6。
//在指定值之前的枚举常量仍按默认方式取值，而指定值之后的枚举常量按依次加1的原则取值。 各枚举常量的值可以重复。

enum letter_set {'a','d','F','s','T'}; //枚举常量不能是字符常量
enum year_set{2000,2001,2002,2003,2004,2005}; //枚举常量不能是整型常量
```

## 友元类

B类是A类的友元，B类的成员函数可以访问A类的private和protect数据，反之不行。

## 构造函数与析构函数

### 顺序问题

先调用成员的构造函数，再调用自己的构造函数。析构顺序反之。

出现继承关系，先调用父类的构造函数。

出现初始化列表形式，构造顺序是根据变量定义的先后顺序来判断的。

## 🆙基类与派生类

基类对象与派生类对象之间存在赋值相容性。包括以下几种情况：

把派生类对象赋值给基类对象。

把派生类对象的地址赋值给基类指针。

用派生类对象初始化基类对象的引用。

反之则不行，即不能把基类对象赋值给派生类对象；不能把基类对象的地址赋值给派生类对象的指针；也不能把基类对象作为派生对象的引用。

## 继承访问权限

1. 基类中protected的成员

> 类内部：可以访问
>
> 类的使用者：不能访问
>
> 类的派生类成员：可以访问

2.派生类不可访问基类的private成员

3.派生类可访问基类的protected成员

> [!NOTE]
>
> 派生类中调用，而不是使用者直接打印赋值操作。

4.派生类可访问基类的public成员

---

不同的继承方式，会将原有的权限转变。

## 静态数据成员

用关键字static声明

该类的所有对象维护该成员的同一个拷贝。

必须在类外定义和初始化，用(::)来指明所属的类。

## 静态成员函数

类外代码可以使用类名和作用域操作符来调用静态成员函数。

静态成员函数只能引用属于该类的静态数据成员或静态成员函数。

## 多态性

多态性：多态就是在同一个类或继承体系结构的基类与派生类中，用同名函数来实现各种不同的功能。

**静态绑定又称静态联编**，是指在编译程序时就根据调用函数提供的信息，把它所对应的具体函数确定下来，即在编译时就把调用函数名与具体函数绑定在一起。 

**动态绑定又称动态联编**，是指在编译程序时还不能确定函数调用所对应的具体函数，只有在程序运行过程中才能够确定函数调用所对应的具体函数，即在程序运行时才把调用函数名与具体函数绑定在一起。

编译时多态性： ---静态联编(连接)----系统在编译时就决定如何实现某一动作,即对某一消息如何处理.静态联编具有执行速度快的优点.在C++中的编译时多态性是通过函数重载和运算符重载实现的。
运行时多态性： ---动态联编(连接)----系统在运行时动态实现某一动作,即对某一消息在运行过程实现其如何响应.动态联编为系统提供了灵活和高度问题抽象的优点,在C++中的运行时多态性是通过继承和虚函数实现的。

## 虚函数

虚函数：虚函数必须实现，如果不实现，编译器将报错。

纯虚函数：仅定义函数原型而不定义其实现的虚函数。

抽象类：包含一个或多个纯虚函数的类。

**Virtual关键字其实质是告知编译系统，被指定为virtual的函数采用动态联编的形式编译。**

```cpp
class X
{
    virtual ReturnType FunctionName(Parameter){
        cout<<"111"<<endl;
    }
	virtual ret_type func_name (param) = 0;
}
```

> [!NOTE]
>
> 不论哪种赋值方式，都只能通过基类对象（或基类对象的指针或引用）访问到派生类对象从基类中继承到的成员， 
>
> 不能借此访问派生类定义的成员。而虚函数使得可以通过基类对象的指针或引用访问派生类定义的成员。

**虚析构函数**

一般析构函数设置为虚函数，这样才能使得对应派生类的清理完整。

## 运算符的重载

重载运算符时返回值为引用的原因

> 1. 引用可以避免二次拷贝开销
> 2. 便于链式操作。 比如 cout << a << b << endl; 应该看成一个整体，而非cout << a; cout << b; cout << endl; 三个部分。
> 3. 对于=运算符，返回值为类对象，引用可以避免默认拷贝构造函数的调用
> 4. 对于<< / >> 运算符，返回值为类对象，因为ostream和istream（还有各种流相关的类比如fstream、stringstream）中的拷贝构造函数和赋值运算符重载都是protected，即只能使用其默认构造函数。而返回时不用引用就会默认调用拷贝构造函数，而对于stream类型的类又没办法调用，因此会出错。
> 5. 对于[] 运算符，返回值为引用是想要修改a[i]就可以修改a的本体内存中的数据。
> 6. 当我们涉及临时变量时，不适用引用传递。

## 函数模板

```cpp
template <class T>
void display(T& a,int n) {
    for(int i=0;i<n;i++)
        cout<<a[i]<<"\t"<<endl;
}
```

### 模板偏特化

```cpp
//template <> 返回类型 函数名<特化的数据类型>(参数表) {}
template<>char * Max<char *>(char *a,char *b) {
    return (strcmp(a,b)>=0)?a:b;
}
```

① 当程序中同时存在模板和它的特化时，特化将被优先调用；

② 在同一个程序中，除了函数模板和它的特化外，还可以有同名的普通函数。其区别在于C++会对普通函数的调用实参进行隐式的类型转换，但不会对模板函数及特化函数的参数进行任何形式的类型转换。

## 异常





## Const

- const定义常量从汇编的角度来看，只是给出了对应的内存地址，而不是像`#define`一样给出的是立即数。
- const定义的常量在程序运行过程中只有一份拷贝，而`#define`定义的常量在内存中有若干个拷贝。
- const常量必须赋初始值。

```cpp
const int *ptr;
//ptr是一个指针，指针指向值的类型是int，指向的值不可变
int val = 3;
ptr = &val;
val = 4;
cout << ptr << endl;
cout << *ptr << endl;
// ptr = 4;  error ptr指向的是常量，不能直接直接通过ptr修改值
// ptr = 10; // error

const int p = 10;
const void * vp = &p; // 保存const对象的地址
//void *vp = &p; //error
cout << vp << endl << endl;
```

> 如果*const*位于`*`的左侧，则const就是用来修饰指针所指向的变量，即指针**指向为常量**。
>
> 不能使用void`*`指针保存const对象的地址，必须使用const void`*`类型的指针保存const对象的地址。

```cpp
int num=0;
int * const ptr1 = &num; //const指针必须初始化！且const指针的值不能修改
// ptr1 本身const，是一个指针，指针指向的类型是int，ptr1是一个指向int不可变的指针
int * t = &num;
*t = 1;

// int num2 = 3;
// ptr1 = &num2; //可以看到报错，左值不可变，因为ptr1本身就是const，不可以改变它的指向

cout<<"num = "<<num<<endl;
cout<<*ptr1<<endl;
*ptr1 = 3;
cout<<"*ptr1 = "<<*ptr1<<endl;
cout<<"num = "<<num<<endl; //num 值也被改变
```

> 如果const位于`*`的右侧，*const*就是修饰指针本身，即指针本身是常量，不能随便改变指向，可以改变指向对象的值。

**函数中使用const**

```cpp
void fun(const A &a);
//参数为引用，引用传递，且避免改变值
```

**类中使用const**

```cpp
//const对象只能访问const成员函数
//任何不会修改数据成员的函数都应该声明为const类型
```

## extern

```cpp
extern int ext;
extern const int ext;
```

为了使变量在其他文件中访问。

## main函数

main函数是许多函数的起点，但不是唯一，可以通过手动设置。

## null nullptr

在C++中将NULL定义为整数 0。

```cpp
int *p = NULL; //表示指针的值是0，认为指针是空指针，编译器将NULL优先解释为整数0。
```

在C中将NULL定义为void类型的指针，`(void*)0`更能体现指针的意义。

nullptr是一个编译期常量，其类型为nullptr_t。它既不是整型类型，也不是指针类型。

在模板推导中，nullptr被推导为nullptr_t类型，仍可隐式转为指针。但0或NULL则会被推导为整型类型。

```cpp
#include <iostream>

int main(int argc, char *argv[]) {
  void* px = NULL;
  // int* py = (void*)0;         //编译错误，不能隐式将void*转为int*类型
  int* pz = (int*)px;           //void*不能隐式转为int*，必须强制转换！

  int* pi = nullptr;            //ok！nullptr可以隐式转为任何其他指针类型
  void* pv = nullptr;           //ok! nullptr可以隐式转为任何其他指针类型

	return 0;
}
```

> [!NOTE]
>
> `nullptr`可以隐式转换为任何其他指针类型。
>
> `(void*) 0`不能隐式转换为其他。

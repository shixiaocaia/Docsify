---
layout: wiki
wiki: Data structure and algorithm
order: 2
title: 线性表
---
## 线性表顺序存储

**获取元素**

判断地址是否合法，返回对应下标数值。

**插入元素**

整体思路：

> 1. 插入位置非法的话，抛出异常
> 2. 如果线性表长度大于等于数组长度，抛出异常或者增加容量
> 3. 从最后一个元素开始向前遍历到第i个位置，分别将他们向后移动一个位置
> 4. 将元素插入到对应位置处
> 5. 表长+1

> 线性表长度是实际存放的数据大小，而数组长度是一个预先申请好的空间大小。线性表的长度应该小于或者等于数组长度。

时间复杂度：

- 最好情况：在表尾插入(即i=n+1)，元素后移语句将不执行，时间复杂度为O(1)。
- 最坏情况：在表头插入(即i=1)，元素后移语句将执行n次，时间复杂度为O(n)。
- 平均情况：n/2![img](http://pic.shixiaocaia.fun/202209060946265.jpeg)

**删除操作**

整体思路：

> 1. 删除位置非法的话，抛出异常
> 2. 取出删除元素
> 3. 从删除元素的位置开始遍历到最后一个元素的位置，分别将他们向前移动一个位置
> 4. 表长减1

时间复杂度：

- 最好情况：删除表尾元素(即i=n),无须移动元素,时间复杂度为0(1)。
- 最坏情况：删除表头元素(即i-1),需移动除第一个元素外的所有元素,时间复杂度为0(n)。
- 平均情况：n-1/2![img](http://pic.shixiaocaia.fun/202209060949661.jpeg)

**顺序存储的优缺点**

优点：无需为表中元素的逻辑关系增加额外的存储空间，可以快速地存取表中任一位置的元素，

缺点：插入和删除操作需要移动大量元素，当线性表进行大量的长度变化时，难以确定存储空间的容量，造成存储空间的碎片。

## 线性表的链式存储结构

为了解决顺序存储中带来的各种问题，引入了链式存储。链式存储中单元地址不一定是连续的。包含指针域和数据域两部分。

> 1. 根据每个节点指针域的数量可以分为单链表和双链表。
> 2. 链表中的第一个节点的存储位置叫做头指针。但实际上我们会在第一个结点中加入一个头结点，这样把所有节点当作中间节点处理，返回时去除空节点。

**单链表的读取**

用一个指针从头开始找，直到遍历到为止。

**单链表的插入**

在p节点后插入s：将s的next指向p->next（原来指向下一个节点），p->next指向s。

```cpp
s->next = p -> next;
p->next = s;
```

整体思路：从头开始遍历到要插入的位置，通过上述方式插入。（插入的节点要自行开辟一段空间）

**单链表的删除**

将p节点指向跳过下一个节点，释放被删除节点的空间即可。

```cpp
p->next = p->next->next;
```

**插入和删除对比顺序存储**

虽然他们时间复杂度都是O(n)，当插入十个数据时，链表一次遍历到后，后续都是直接插入，而顺序存储每一次都要移动n-i个节点，总体效率更低。

**创建单链表**

分为头插入和尾插入。

**释放单链表**

通过两个指针，用一个指针q指向下一个节点，然后释放当前节点p，再将p移动到下一个节点q位置。(如果直接释放肯定是不对的，当free时，p指针域也释放了，找不到下一个节点，因此必须找个指针保存)

**静态链表**

通过结构体数组模拟date和next，不需要移动数组，通过下标来操作。

**循环链表**

将单链表终端结点的指针端由空指针改为指向头结点，使得单链表形成一个环。此外，循环链表也可以设置一个头结点。

循环链表和单链表的差异在于：判断p->next为空还是为头结点，以此来判断循环结束。

**双向链表**

在单链表的基础上，每一个结点中，再设置一个指向其前驱节点的指针域，一个指向前驱结点，一个指向后驱结点。


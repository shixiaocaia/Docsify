## 变量命名

**小驼峰、大驼峰命名法**

> - 小驼峰
> - 第一个单词首字母小写，后面其他单词首字母大写。例如 `int myAge;`
> - leetcode上给出的默认函数的命名就是小驼峰
> - 适用语言：java、 go、 C++

> - 大驼峰
> - 大驼峰法把第一个单词的首字母也大写了。例如：`int MyAge;`
> - 适用语言：java、 go、C++的函数和结构体命名

**下划线命名法**

> - 下划线命名法是名称中的每一个逻辑断点都用一个下划线来标记，例如：`int my_age`
>
> - 适用语言：python和Linux环境下C/C++编程

**匈牙利命名法**

> - 匈牙利命名法是：变量名 = 属性 + 类型 + 对象描述，例如：`int iMyAge`，这种命名是一个来此匈牙利的程序员在微软内部推广起来，然后推广给了全世界的Windows开发人员。缺点：难维护。
> - 适用语言：Windows下C/C++编程

## 水平留白（代码空格）

- 操作符左右一定有空格，例如

```cpp
i = i + 1;
```

- 分隔符（`,` 和`;`）前一位没有空格，后一位保持空格，例如：

```cpp
int i, j;
for (int fastIndex = 0; fastIndex < nums.size(); fastIndex++)
```

- 大括号和函数保持同一行，并有一个空格例如：

```cpp
while (n) {
    n--;
}
```

- 控制语句（while，if，for）前都有一个空格，例如：

```text
while (n) {
    if (k > 0) return 9;
    n--;
}
```

## 使用库函数

- 如果题目关键的部分直接用库函数就可以解决，建议不要使用库函数。

- 如果库函数仅仅是 解题过程中的一小部分，并且你已经很清楚这个库函数的内部实现原理的话，那么直接用库函数。
- 关注
  - 了解库函数实现
  - 时间复杂度

## 学习Mark

- Linux环境使用
  - VIM编辑器

## 时间复杂度

**定义**

- 时间复杂度是一个函数，它定性描述该算法的运行时间。
- 假设算法的问题规模为n，那么操作单元数量便用函数f(n)来表示，随着数据规模n的增大，算法执行时间的增长率和f(n)的增长率相同，这称作为算法的渐近时间复杂度，简称时间复杂度，记为 O(f(n))。

**什么是大O**

- 大O用来表示上界的，当用它作为算法的最坏情况运行时间的上界，就是对任意数据输入的运行时间的上界。

- 这里是大O指的是一般情况，不是严格上界，比如快速排序是O(nlogn)，但是其最坏情况下是O(n^2)。

**不同数据规模的差异**
  ![](http://pic.shixiaocaia.fun/202208071915130.png)

- 不同算法的时间复杂度在不同数据输入规模下，有一定差异。

- **为什么忽略常数项系数：**
  大O就是数据量级突破一个点且数据量级非常大的情况下所表现出的时间复杂度，这个数据量也就是常数项系数已经不起决定性作用的数据量。

- **算法时间复杂的的一个排行**

  O(1)常数阶 < O(logn)对数阶 < O(n)线性阶 < O(n^2)平方阶 < O(n^3)立方阶 < O(2^n)指数阶。

**复杂表达式的化简**

遵循以下的一定准则来简化：

1. 去除加法常数项
2. 去除常数系数
3. 只保留最高数量级项

根据上述，我们一般考虑log 级别的，忽略了底数



## 空间复杂度

**定义**

- 是对一个算法在运行过程中占用内存空间大小的量度，记做S(n)=O(f(n)。
- 空间复杂度(Space Complexity)记作S(n) 依然使用大O来表示。
  递归中O
  O = 每次递归的空间复杂度 * 递归深度



## 内存消耗(C++)

计算程序占用多大内存

mark.

## 内存对齐

- 为什么会有内存对齐：
  1. 平台原因：不是所有的硬件平台都能访问任意内存地址上的任意数据，某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。为了同一个程序可以在多平台运行，需要内存对齐。
  2. 硬件原因：经过内存对齐后，CPU访问内存的速度大大提升。




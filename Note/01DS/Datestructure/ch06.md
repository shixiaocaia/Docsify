## 有序表查找

### 二分查找

时间复杂度：*O*(log<sub>n</sub>)

### 插值查找

根据要查找到的关键字key与查找表中最大最小记录的关键字比较后的查找方法，核心在于插值公式mid = $low$ + $key-a[low] \over a[high]-a[low]$,

其他部分的代码就是二分的内容。

### 斐波那契查找

尽管时间复杂度都是logn，但是斐波那契根据斐波那契数列下标来查找更新，在大部分时候还是优于二分的，并且斐波那契只需要进行加减运算，对比二分、插值这些。

## 线性索引查找

线性索引就是将索引项集合组织为线性结构，也称为索引表。

### 稠密索引

就像是在小本子里记录东西放那了，然后需要用的时候去查到一下放哪里了。

稠密索引构建一个索引表，分别由存放了关键码和索引，关键码对应实际数据中的关键码头部。

但是当数据量过大时，索引表也会很多，索引耗时也很增加。

### 分块索引

分块有序，是把数据集的记录分成了若干块，并目这些块需要满足以下两个条件：

1. 块内无序，即每一块内的记录不要求有序。当然,你如果能够让块内有序对查找来说更理想，不过这就要付出大量时间和空间的代价，因此通常我们不要求块内有序。
2. 块内有序，例如，要求第二块所有记录的关键字均要大于第—块中所有记录的关键字,第三块所有记录的关键字均要大于第二块所有记录的关键字……因为只有块间有序，才有可能在查找时提高效率。

### 倒排索引

在搜索引擎中就是一种应用，系统将单词做一下微小变化处理，统计出一张索引表，索引项的通用结构是：次关键码例如英文单词，和记录号表例如文章编号。

## 二叉排序树（二叉查找树

一颗二叉树，要么是空树，或者是具有下列性质的二叉树：

1. 左子树不为空的话，所有左子树上所有的结点值均小于他根节点的值。
2. 右子树不为空的话，所有右子树上所有的结点值均大于他根节点的值。
3. 他的左右子树分别为二叉排序树。

构建二叉排序树，是为了提高查找和插入删除关键字的速度。

时间复杂度：*O*log<sub>n</sub>

### 删除操作

**叶子节点**

直接删除。

**只有左子树/右子树**

独子继承父业。

**左右都有**

中序遍历这棵树，然后找到要删除节点的直接前驱和直接后继结点，替代要删除的结点，再删除这个结点。

## 平衡二叉树（AVL树）

AVL树是一种**二叉排序树**，其中每一个结点的左子树和右子树的高度差至多等于1。平衡是指高度平衡。

平衡因子BF：二叉树上结点的左子树高度减去右子树高度的值。根据定义可知，BF值可以取-1，0，1。

最小不平衡子树：距离插入结点最近的，且BF绝对值大于1的结点为根的树。

### 实现原理

AVL树基本思想是在构建二叉排序树的同时，插入新的结点时，判断是否破坏了BF绝对值不大于的1的规则，否则的话进行调整。

**旋转的方法**

当左子树的高度大于右子树的高度时，右旋。当右子树的高度大于左子树高度时，左旋。

> 当最小不平衡子树的根节点与子结点BF值符号不相同时，不能够简单的左旋右旋，要先进行调整。

## 多路查找树（B树）

多路查找树：每一个结点的孩子树可以多余两个，且每个结点可以存储多个元素。

### 2-3树

### 2-3-4树

### B树

### B+树

## 哈希表（散列表）

散列技术是在记录的存储位置和它的关键字之间建立一个确定的对应关系f，使得每个关键字key对应一个存储位置。

### 散列函数的构造

为了避免所有的关键词产生冲突，同时需要构造耗费的计算时间，提高查找的效率。

为了避免冲突，最好的办法是尽量让散列地址均匀地分布再存储空间中，保证存储空间的有效利用，减少处理冲突而耗费的时间。

**直接构造法**

选取关键字的某个线性函数值作为散列地址，即f(key) = a × key + b;

比如我用用1-26的下标存储文章中每个字母的个数。

**数字分析法**

适合处理关键字位数比较多的情况，事先知道关键字的分布情况且关键字的若干位分布较为均匀，可以考虑用这个情况。

**平方取中法**

将关键字进行平方处理，然后再选取其中的一部分，作为关键字。适用于不知道关键字的分布，位数又不是很多的情况。

**折叠法**

折叠法是将关键字从左到右分割成位数相等的几部分（注意最后一部分位数不够时 可以短些），然后将这几部分叠加求和，并按散列表表长,取后几位作为散列地址。

**除留余数法**

最常用的构造散列函数的方法，常见的散列表长为m散列函数公式为:

> f(key) = key mod p (p <= m)

### 处理散列冲突

**开放定址法**

> f(key) =(f(key) + d<sub>i</sub>) mod M (d<sub>i</sub> < M)

当存放的地址被占用时，使用下一个位置的，在散列表没有用完时，肯定能够找到合适的位置去存放。

我们将di的取值增加平方运算，可以不让关键字都聚集到在某一块区域，这样称为二次探测法。

> 取di为 1<sup>2</sup>, -1<sup>2</sup>, 2<sup>2</sup>

**再散列函数法**

使用多个散列函数，当某个散列函数发生冲突时，换一个构造的散列函数，但是这样的导致了计算的时间的增加。

**链地址法**

当发生冲突时，我们将每个位置作为一个单链表的头结点，当发生冲突时，直接在当钱位置给单链表增加结点，不需要更换地址。

**公共溢出区法**

将冲突的元素单独构建一个溢出表存放。

查找时先去散列表中查找，没有找到时，前往溢出表寻找。


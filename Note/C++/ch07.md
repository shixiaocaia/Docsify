## 做题过程中的感受

**引用传递**

在做到LC.332，这边的回溯递归时，如果我的形参既不是全局变量，也不是引入传递的话，在回溯过程中传递的是子函数作用域下的数值，在此作用域结束时就被消除了，使用引入的方式，是直接对数组进行xiu'gai

## C++多文件编程

稍微大一点的项目都不会是单个文件的，多文件的好处实在太多，模块开发、分工协作、代码复用、结构清晰、模块更新…

cpp程序一般分为三类文件：
  - 头文件( .h )。放置各种声明，用于被cpp文件包含。
  - 模块文件（.cpp）。放置一些函数定义，也称为功能模块。
  - 主程序文件（.cpp）。包含main()的文件，程序入口，调用模块文件实现的方法。

**头文件**

C++编译过程原理：C++把每个文件单独编译出来，再通过链接把编译出来的多个文件组成一个可执行程序。

为了解决使用其他文件的函数时重复繁琐的声明，将所有声明类的语句放到一个文件里，称为头文件。头文件的内容会在编译前被粘贴到源文件中，这样在编译的时候就能正常通过了。

此外，头文件的内容一般都会使用条件编译预处理语句（如上）包住，防止因为依赖关系多次被包含。

```cpp
#ifndef HEADER_H
#define HEADER_H
void fun();
#endif
```

头文件中常包含以下内容：

- 函数声明
- 类定义、结构定义：用函数定义的逻辑想，似乎不能放在头文件中。但它应该放在头文件。第一，每个cpp文件应该有一个定义，在编译的时候编译器才知道怎么为对象分配空间。其次，类型定义不会在内存上分配空间。
- 模板函数：编译器必须在编译的时候根据函数模板实例化对应的函数，所以应该放在头文件。
- 内联函数：编译期间被插到调用位置，所以也要放在头文件。
- **函数定义：不要！**C++规定一个程序同签名的函数只能有一个定义。如果你把函数定义放在头文件件，并且同一个程序的多个cpp文件包含了该头文件，这样，在链接的时候会发现多个定义版本，链接报错。
- **变量定义：不要！**与上面类似，被多个文件包含的时候会出现多次定义同一个变量，链接错误。但是，static变量和extern变量可以，以及宏定义的常量，因为这些在多个文件出现并不会出错。

**源文件**

除去头文件，剩下的内容可以放在源文件中，常分类模块文件和主程序文件。

**多文件编译**

如果是使用Windows下的集成开发环境的，大可直接Build，一键搞定，但你对这个过程的理解就可能差点。所以我以linux上为例，最简单的多文件编译命令：

```cpp
g++ main.cpp fun.cpp -o out   #列举所有要编译的文件

```

也可以单独编译成 .o文件之后再链接：

```cpp
g++ -c main.cpp -o main.o
g++ -c fun.cpp -o fun.o
g++ main.o fun.o -o out
```

第二种相对麻烦，但是提供了一个优点——模块编译更新。你只需要编译你修改过的文件，再跟其他的链接，无需再次对整个项目编译。

在实际的项目中，项目文件可不是小数目，无论上面的那种方式，你都需要一一列出文件，不实际。IDE工具自然没有这种烦恼。不过Linux也会使用Makefile进行项目管理，实现自动编译。

## 区分“.”和“->”

```cpp
class student{
public:
    string name;
}

student *xy; //*xy是对象(结构体），所以可以这样写
(*xy).name ="123"; //同样等价为xy->name = "123"; 指针用->

student xy;
xy.name = "123";//普通类的成员属性访问 对象用点

```

## 读懂C++类型声明

**步骤：**

- 第一步，找到变量名，如果没有变量名，找到最里面的结构
- 第二步，向右看，读出你看到的东西，但是不要跳过括号
- 第三步，再向左看，读出你看到的东西，但是也不要跳过括号
- 第四步，如果有括号的话，跳出一层括号
- 第五步，重复上述过程，直到你读出最终的类型

**例子**

```cpp
int *v[5];
1. 找到变量名v
2. 向右看，尺寸为5的数组  
3. 右边没有了，向左看，是个指针，指向int
v是一个有5个指向int类型的指针的数组——指针的数组

int (*v)[5];
1. 找到变量名v
2. 向右看，有一个括号，不能跳过，是一个指针
3. 向右看，指向数组
3. 右边没有了，向左看，指向int
v是个指向有5个整数的数组的指针。——数组的指针
```
```cpp
int func();
//func是一个返回int的函数

int (*func)();
//func是一个指针，是一个函数，返回值是int型，所以func是一个指针，返回一个int型的函数，即函数指针。

int (*V[])();
// v是一个数组，数组内每个元素是指针，每个指针指向一个函数，返回值是int。整体看，v是一个int型函数指针组成的数组。
```

```cpp
int const a;
const int a;
// a的值不可变。

int const *r;
// r 向左看，是一个指针，所以r是一个指向const int的指针，*r不可变，但是r本身不是const，所以可以将r指向其他地址，地址内的内容不可变

int *const r;
// r是一个const，r是一个const类型的指针，r本身的值不可变，int类型不是const，所以*r内容可以改变，指向的地址不可变，地址内容可变
```

## 栈、堆和内存管理

**stack**

存在于某作用域的一块内存空间。例如调用函数，函数本身会形成一块stack用来放置接受的参数，返回值。包括了函数体内声明的任何变量。

离开作用域会自动释放。一般这种创建的object，我们称之为auto object。

当我们加了static 关键词，变量称之为static object，直到程序结束才被消除。

global object 全局变量，定义在main函数之外，直到程序结束。

**heap**

操作系统提供的一块global内存空间，程序可以动态分配若干区域。当然你申请就需要自己销掉。

### 几种object类型

离开作用域会自动释放。一般这种创建的object，我们称之为auto object。

当我们加了static 关键词，变量称之为static object，直到程序结束才被消除。

global objects 全局变量，定义在main函数之外，直到程序结束。

heap objects 声明周期在deleted之前。在作用域之外，没有delete将造成内存泄漏。

### 内存管理

  ![image-20220925090726739](http://pic.shixiaocaia.fun/202209250907017.png)

首先我们观察最左侧，最上方和最下方是cookie，灰色的是调式自带的部分，不同的编译器可能有不同的大小，然后complex类型占用2连个double，8个字节，最后由于内存块的大小是16的倍数，52不满大小，再补3个块，构成64，多余的部分在后面会有一定的作用。

左边数第二个，是非调式情况下，只有一个cookie + 变量占用，cookie能告知计算机需要回收多大的分配空间。41，末尾的0和1表示分配和回收。

动态分配数组时，会多一个位置存放数组的大小。


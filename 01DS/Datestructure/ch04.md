## 树的参数概念

**节点的度**

结点拥有的子树数称为结点的度。度为0的结点称为叶结点。树的度是树各个结点度的最大值。

**结点的层次**

从根开始定义，根为第一层，根的孩子为第二层。同一层的结点互为堂兄弟。

树中结点的最大层次称为树的深度或高度。

**有序树**

如果将树中结点的各子树看成从左至右是有序的，不能互换的，则称该树为有序树，否则为无序树。

**森林**

m（m≥0）棵互不相交的树的集合。对树中每个结点而言,其子树的集合即为森林。

**二叉树**

每个结点最多有个两棵子树，所以二叉树中不存在度大于2的结点。

左右子树是有顺序的。

即使树中某个结点只有一颗子树，也要区分是左子树还是右子树。  

## 二叉树的性质

- 二叉树的第 i 层至多有2<sup>i-1</sup>个结点（i≥1）

- 深度为k的二叉树至多有2<sup>k</sup>-1个结点。(k>= 1)
- 对任何一颗二叉树T，如果其终端结点数为n<sub>0</sub>，度为2的结点数为n<sub>2</sub>，则n<sub>0</sub> = n<sub>2</sub> + 1。
- 具有n个结点的完全二叉树的深度为⌊log<sub>2</sub><sup>n</sup>⌋ + 1
- 如将一棵有n个结点的完全二叉树自顶向下，同层自左向右连续为结点编号0,1, …, n-1，则有： 

    1）若i = 0, 则 i 无双亲,   若i > 0, 则 i 的双亲为⌊ (i -1)/2」
    2）若2\*i+1 < n, 则i 的左子女为 2\*i+1，若2\*i+2 < n, 则 i 的右子女为2*i+2
    3）若结点编号i为偶数，且i != 0,则左兄弟结点i-1.
    4）若结点编号i为奇数，且i != n-1,则右兄弟结点为i+1.
    5）结点i 所在层次为⌊ log2(i+1) 」

## 二叉数的种类

**满二叉树**

如果一棵二叉树只有度为0的结点和度为2的结点，并且度为0的结点在同一层上，则这棵二叉树为满二叉树。

![二叉树](http://pic.shixiaocaia.fun/202209111602740.png)

这棵二叉树为满二叉树，也可以说深度为k，有2<sup>k</sup>-1个节点的二叉树。

**完全二叉树**

在完全二叉树中，**除了最底层节点可能没填满外，其余每层节点数都达到最大值**，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2<sup>k-1</sup>  个节点。

![img](http://pic.shixiaocaia.fun/202209111604458.png)

最后一幅图不是完全二叉树，因为最下面一层有一个左节点为空，后面还有非空节点。

**二叉搜索树**

前面介绍的树，都没有数值的，而二叉搜索树是有数值的了，**二叉搜索树是一个有序树**。

- 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；
- 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；
- 它的左、右子树也分别为二叉搜索树

下面这两棵树都是搜索树 ![img](http://pic.shixiaocaia.fun/202209111607178.png)

**平衡二叉搜索树**

平衡二叉搜索树：又被称为AVL（Adelson-Velsky and Landis）树，且具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。

如图：

![img](http://pic.shixiaocaia.fun/202209111607855.png)

最后一棵 不是平衡二叉树，因为它的左右两个子树的高度差的绝对值超过了1。

> 初始值为0看：
>
> 树的高度：高度是从下往上数的，节点的高度是该节点到叶子节点的最长路径（边数）。
>
> 树的深度：深度是从上往下数的，节点的深度是根节点到这个节点所经历的边的个数。
>
> ![img](http://pic.shixiaocaia.fun/202209111614981.png)

## 二叉树存储

顺序存储
![img](http://pic.shixiaocaia.fun/202209111618478.png)

> 用数组来存储二叉树如何遍历的呢？
>
> 如果父节点的数组下标是 i，那么它的左孩子就是 i \* 2 + 1，右孩子就是 i \* 2 + 2。

**链式存储**

![img](http://pic.shixiaocaia.fun/202209111618100.png)

用指针方式，一个节点元素，左右指针分别指向左右两个节点。

用链式表示的二叉树，更有利于我们理解，所以一般我们都是用链式存储二叉树。


## 二叉树的定义

```cpp
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x) : val(x), left(NULL), right(NULL) {} //初始化列表方式进行有参构造
};
```

**在现场面试的时候 面试官可能要求手写代码，所以数据结构的定义以及简单逻辑的代码一定要锻炼白纸写出来。**

## 二叉树的存储结构

**顺序存储**

完全二叉树顺序存储，直接按照相应的下标对应其同样的位置。对于一般的二叉树，可以按照完全二叉树编号，将不存在的结点用符号标记，但是顺序存储一般用用于完全二叉树，对于一般的二叉树用顺序存储浪费大量空间。

## 二叉树的遍历

二叉树遍历主要分为深度优先遍历和广度优先遍历。

### 深度优先遍历

深度优先遍历又细分为

- 前序（中左右）、中序（左中右）、后序（左右中）遍历三种方式。
- 可以用递归法，迭代法，一般用递归法，用栈实现。

**递归方法的逻辑**

> 确定递归函数的参数和返回值： 
>
> 确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。
>
> 确定终止条件： 
> 写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。
>
> 确定单层递归的逻辑： 
> 确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。

**迭代方法**

> 先序遍历：中左右。先将中点压入栈中，先读入非空右结点，然后再读入非空左节点，这样后进先出，变成了中左右。
>
> 中序遍历：左中右。用一个指针变量找到左结点底层，为空时出栈，访问右节点，右节点的左节点最底层，持续循环。所以循环条件是指针非空或者栈非空
>
> 后序遍历：左右中。改自先序遍历，先入栈中，然后先入左节点，再入右节点，则顺序为中右左，再将整体反转变成，左右中。

**统一的迭代方法（标记法）**

> 按照三种顺序遍历方式，处理入栈和放入结果集的结点。每次将处理完的结点入栈，再紧接着一个空指针，表明该结点处理完毕可以放入结果集。

### 广度优先遍历
- 广度优先遍历又细分为
  - 层次遍历，逐层，从左往右访问结点。
  - 迭代法，一般用队列实现。

## 哈夫曼树 哈夫曼编码

**定义**

- 树的路径长度就是从树根到每一结点的路径长度之和。
- 树的带权路径长度为树中所有叶子结点的带权路径长度之和。
- 哈夫曼树：带权路径长度最小的的二叉树。也称为最优二叉树。

**哈夫曼树的构造方法**

将序列进行排序，选取两个最小值，之和生成一个新结点加入序列中排序，再选取两个值，重复上述操作。

**哈夫曼编码**

当年为了解决远距离数据传输的问题。比如当我们传递一组文字，用相应二进制数字传输的话，就会很冗长。这时如果考虑使用哈夫曼编码，将文字出现的频率或者次数当作权重，将字符作为叶结点，构造一个哈夫曼树，然后将哈夫曼树上的左分支代表0，右分支代表1，最后我们将树根到叶子结点所经过的0，1形成一个新的编码，这样最终能够节省一定的存储和传输成本。

为了接收方能够顺利的解码，我们要满足发送方和接收方的采取的相同的编码规则，同时要注意设计长短不等，任一字符的编码都不是另一个字符编码的前缀。

## Tostudy

**线索二叉树**

**树、森林与二叉树的转换**




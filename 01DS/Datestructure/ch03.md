## 栈

**两栈共享空间**

为了解决使用多个栈时，一个栈溢出，而其他栈有空闲的问题。我们可以使用一个数组来模拟存储两个栈。

我们让一个栈的栈底为数组的始端（下标为0处），另一个放在数组的末尾处（n-1)。这样在入栈时都是向中间靠拢。分别用top1，top2指向两个栈栈顶，当top1 = -1,top = n 时两个栈为空。当top1 = n-1时，top1 栈1满了，top2 = 0 时，栈2满了。 即当top1 + 1 = top2为满栈。再增加一个变量判断在对具体哪一个栈操作。

这里主要是针对相同数据类型的变量，进行操作。

**链栈**

将头结点设置为栈顶，不断进行入栈和出栈的操作。

**栈的应用**

- 斐波那契数列的实现

斐波那契数列最简单是用数组实现，也可以用递归实现。递归实现更加简单明了，但是会有大量的函数副本，造成时间和内存的浪费。

整个递归的过程，不断调用函数本身，又返回的上一级的过程，十分符合栈这样的数据结构。每一层递归，将函数的局部变量，参数值以及返回地址入栈，退回时再出栈弹出。

- 后缀表达式的计算

经典的栈的算法题，包括括号匹配的之类问题。

- 中缀表达式转后缀表达式

1. 从左到右遍历中缀表达式的每个数字和符号，若是数字就输出
2. 若是符号，判断与栈顶符号的优先级。是右括号或者优先级不高于栈顶符号的，则栈顶元素依次出栈输出，当前符号进栈，一直到输出后缀表达式。

通常情况下，计算机将我们日常看到的中缀表达式转换为后缀表达式，然后再计算后缀表达式的值。

## 队列

**顺序存储**

每次在队首出队，在队尾插入，每次出队时全队中数值向前移动。

改进 1：引入front和rear指针，分别指向队头元素和队尾元素的下一个位置，当front = rear时为空队列。

问题：在队前不断出队时，移动front指针，前面的空间空出来了，当后续元素插入队尾时，可能会造成数组越界，但是实际上队前仍有空间，这样现象称为“**假溢出**”。此外，rear指针指向位置也可能出现越界问题。

**循环队列**

为了解决上述假溢出问题，将头尾相连接，后面满了，在头部插入元素。

使得rear可以指向下标为0的位置，可以指向空闲的内存地址，但是当rear = front时无法判断为空还是满了。

为了解决上述问题，增加一个flag标志位，来判断是队满还是为空。或者是用rear = front 来判断队列为空，用 front = rear + 1 来判断队满，但是由于循环队列中rear位置可能小于front，可能整整大一圈。通过取余操作判断队满，（rear + 1) % QueueSize == front。通过取余操作可以解决，front = 0，rear = 4, Size = 5 这种情况判断队满。

另外，当rear＞front时，如下图。此时队列的长度为rear-front。但当 rear＜front时,如下图3，队列长度分为两段，—段是QueueSize-front,另一段是0＋rear，加在-起’队列长度为rear - front＋QueueSize。

综上所述，通用的队列长度公式为：（rear - front＋QueueSize)%QueueSize

**链式存储**

队列的链式存储结构，其实就是线性表的单链表，只不过只允许尾进头出，简称链队列。

空队列时，front和rear都指向头结点。

**对比**

|          循环队列          |           链队列           |
| :------------------------: | :------------------------: |
|          空间固定          |        空间长度灵活        |
| 存储元素个数和空间上的浪费 | 申请、释放节点产生时间开销 |
|       长度固定时使用       |     无法预测长度时使用     |

## 排序的基本概念

**排序的稳定性**

举个栗子：当小明和小红总分相同时，在不排序时，小明在小红之前，按照总分排序之和，如果小明还是在小红之间，此时是一个稳定排序，否则改变顺序后就不是稳定的排序。

**内排序和外排序**

内排序：待排序的所有记录都被放置在内存中。主要包括了插入排序、交换排序、选择排序和归并排序。

外排序：由于排序的记录的个数太多，不能同时放置在内存当中，整个排序过程过程中需要在内外存之间多次交换数据才能进行。

简单排序：冒泡排序、简单选择排序和直接插入排序。

改进算法：希尔排序、堆排序、归并排序、快速排序。

## 冒泡排序

**基本思想**

两两比较相邻记录的关键字，如果反序则交换，直到没有反序的记录位置。

**冒泡排序**

**冒泡排序的优化**

增加一个flag标签，判断已经有序的情况下，去除无意义的循环判断。

**时间复杂度**: *O*(n<sup>2</sup>)

## 简单选择排序

**基本思想**

通过n - i次关键字间的比较，从 n - i + 1个记录中选出关键字最小的记录，并和第 i 个（ 1 <= i <= n) 个记录交换。

每次默认当前位置是最小值，然后套一个第二层循环，去寻找是否有比当前的值更小的数值，如果有swap，否则continue。

**时间复杂度**：*O*(n<sup>2</sup>)

## 直接插入排序

**基本思想**

将一个记录插入到已经排好序的有序表中，从而得到一个新的、记录数增1的有序表。

**时间复杂度**：*O*(n<sup>2</sup>)

## 希尔排序



## 堆排序

堆是具有下列性质的完全二叉树:  每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆。或者每个结点的值都小于或等于其左石孩子结点的值,称为小顶堆。

堆排序：将待排序的序列构造成一个大顶堆。此时的序列的最大值就是堆顶的根结点。将他移走（与堆数组末尾元素进行交换），剩下的序列重新形成一个堆，这样就会得到一个次大值，反复执行，最终能得到一个有序序列。

待解决的问题：如何由一个无序序列构建成一个堆？如果将输出堆顶元素后，调整剩余元素成为一个新的堆？

**时间复杂度**：*O*(nlog<sub>n</sub>)



## 归并排序

假设初始序列含义n个记录，则可以看到是n个有序的子序列，每个序列长度为1，然后两两归并，得到不小于n/2的长度为2或者为1的有序子序列，再两两归并，知道得到一个长度为n的有序序列。





## 快速排序


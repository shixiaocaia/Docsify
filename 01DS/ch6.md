## 贪心一般解题步骤

贪心算法一般分为如下四步：

- 将问题分解为若干个子问题
- 找出适合的贪心策略
- 求解每一个子问题的最优解
- 将局部最优解堆叠成全局最优解

其实这个分的有点细了，真正做题的时候很难分出这么详细的解题步骤，可能就是因为贪心的题目往往还和其他方面的知识混在一起。

## 例题

**[455. 分发饼干](https://leetcode.cn/problems/assign-cookies/)**

> 采用一个思路，小饼干喂饱小饼干的人，把大的留给胃口更大的，这样的全局思路，喂饱更多的人。

**[376. 摆动序列](https://leetcode.cn/problems/wiggle-subsequence/)**
> 实际上转换为了一个数值波峰序列，前后差值为正就是上坡，前后差值为负就是下坡。通知共有多个这样个上下的点。
>
> 贪心的情况即统计共有多少个峰值点即可，即也默认删除了一些中间没有正负变化点的点。
>
> 用一个变量记录前一个差值，即前一个的上下波动情况。

> DP:

**[53. 最大子数组和](https://leetcode.cn/problems/maximum-subarray/)**

> sum += nums[i]; //计算和
>
> ans = max(sum, ans); //每次都更新最值，因为可能当前为正，后面越来越小但是和依旧为正
>
> sum = max(0, sum); //如果当前和已经为负值了，对后面的序列都是负影响，不如直接从新开始。

> DP:

**[122. 买卖股票的最佳时机 II](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/)**

> 赚的是差价。
>
> 计算相邻两天的差价，如果值为正说明前一次买今天赚，计算差值序列，统计所有正值情况即可。
>
> 如果持续为正收入差价即为正值差价和，如果否则就是前面正值。

**[55. 跳跃游戏](https://leetcode.cn/problems/jump-game/)**

> 每次贪心取极限，最后判断覆盖的范围能够包含末尾。
>
> 特判：如果只有一个点，那即终点。

**[45. 跳跃游戏 II](https://leetcode.cn/problems/jump-game-ii/)**

> 与上一题的区别，求最短的步数。局部最优是每一步尽可能走得远，全局最优是一步尽可能多走，继续往前走。
>
> 当我们当前这一步等于当前最远距离时：
>
> 1. 等于最远距离，跳出
> 2. 不等于，那么步数+1，更新最远距离继续向前走

**[1005. K 次取反后最大化的数组和](https://leetcode.cn/problems/maximize-sum-of-array-after-k-negations/)**
> 很容易想到对负值取反，剩余的取反次数给绝对值最小的数进行操作。
>
> 这里没有想到的一个点是对nums数组的取绝对值之和，从大到小排序，这样我们能够优先对负数最小值取负变正。如果还剩余次数，对绝对值最小的取负也是影响最小的。


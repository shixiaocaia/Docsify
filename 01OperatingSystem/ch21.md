## 无存储现象

最简单的存储器抽象是根本没有抽象的。

在没有存储器抽象的系统中实现并行的一种方法是使用多线程编程。也可以通过将内存中的内容暂时存到磁盘中，读入下一个程序到内存当中。保证一个时间内内存中只有一个程序，就不会产生冲突。

## 地址空间

### 概念

地址空间是一个进程可以用于寻址内存的一套地址集合。

每一个程序都有一个自己独有的地址空间，使得一个程序对应的地址28所对应的物理地址与另一个程序中的地址28所对应的物理地址不同。

**基址寄存器与界限寄存器**

使用动态定位，将每个进程的地址空间映射到物理内存的不同部分。

经典办法通过两个特殊寄存器实现。基址寄存器用于存放程序物理地址，界限寄存器存放了程序的长度。

在每个地址送到内存之前，会自动加上基址寄存器的内容，同时也要判断地址越界问题。

> 实际中使用这个方法较慢，因为加法运算进位传递问题，在没有使用特殊电路时很慢。

### 交换技术

一个进程完整调入内存当中，但是往往一个系统需要同时运行大量的进程，如果把所有进程加载到内存当中，内存不够的情况下是做不到。

实现内存超载的技术，交换技术，虚拟内存。

**交换技术**将空闲的进程主要存储在磁盘上，当它们不运行时就不会加载到内存中。

在内存空间没有用完时，可以加载多个进程，当内存空间不够用时，将暂时不适用的进程交换到磁盘当中，腾出空间可以加载其他进程。

这样就会带来一个问题，**内存紧缩**问题

> 在我们使用上一个进程交换腾出的空间时，可能会造成多个空闲区。
>
> 可以通过将进程向下移动，有可能将这些空闲区合并，称为内存紧缩。
>
> 但是实际中我们并不这样使用，会耗费大量的CPU时间。

另一个问题是，考虑进程的数据段增长问题：

> 如果与空闲区相邻，可以直接分配。如果是和进程相邻，要交换到更大空闲区当中。否则的话只能挂载到磁盘当中，知道有足够的空闲空间使用。
>
> 考虑大多数进程在运行时数据段都会增长，在进程换入或者移动进程时分配一些**额外的内存**。
>
> 为了节省空闲区，避免交换时浪费，可以考虑两个相邻的进程，共用一段空闲区，从不同的方向进行增长。

### 空闲内存管理

针对动态分配内存，操作系统必须对其进行管理：

**位图**

将内存划分成多个分配单元，每个分配单元对应位图中一位，0表示空闲，1表示占用。

分配单元的大小是一个重要的设计问题，过小位图过大，过大会造成一定数量的内存大小浪费。

**链表**

维护一个记录已分配内存段和空闲内存端的链表。

一个链表结点或者包含一个进程，或者是两个进程间的一块空闲区。

当按照地址顺序在链表中存放进程和空闲区时，有以下的几种算法为创建的进程分配空间。

**首次适配（first fit）**

沿着段链表进行搜索，知道找到一个足够大的空闲区。一般情况下将空闲区分为供进程使用和为下一次划分的空闲区使用。

**下次适配（next fit）**

在首次适配的基础上，使用上一次划分后的空闲区，而不是重头开始找合适的空闲区。

**最佳匹配（best fit）**

搜索整个链表，从开始到结束，找出能够容纳进程的最小空间，而不是通过拆分的方法。

可以通过设置两个链表分别存放空闲区信息和进程实际存放，对空闲区进行排序，找到的第一个就是最佳适配这个进程的最小空间。

**快速适配（quick fit）**

为那些常用的空闲区维护单独的链表。

但是当一个进程使用空闲区，剩下的空闲区需要进行合并，否则无法利用小空闲区。

### 虚拟内存

交换技术带来一个问题就是，磁盘的交换速度有限，但是进程的大小在不断的增加。

虚拟内存的思路是每个程序都有自己的地址空间，每个空间被分配成多个块，每一个块被称为一页或者**页面**，每一页都有连续的地址范围，这些页又映射到内存当中。

> 但不是所有的页都要加载到内存当中。

**分页**

> 我们程序所使用的内存地址叫做**虚拟内存地址**（*Virtual Memory Address*）
>
> 实际存在硬件里面的空间地址叫**物理内存地址**（*Physical Memory Address*）

在使用虚拟内存的情况下，虚拟地址不是直接送到内存总线上，而是被送到内存管理单元（MMU），MMU把虚拟地址映射为物理内存地址。

> 虚拟地址空间按照固定大小划分成的单元称为**页面**。
>
> 在物理内存中对应的单元称为**页框**。

当程序访问一个未被映射的**页面**时，MMU发现后，使得CPU陷入到操作系统中，这个陷阱称为**缺页中断**或者**缺页错误**。

> 这时候OS会去找一个很少使用的页框将之存放到磁盘当中，然后将需要访问的页面放到该页框中，修改映射关系，然后重启刚才引发陷阱的命令。

> **页面大小**
>
> 对应一个虚拟地址4096，将输入16位地址分为4位的页号和12位的偏移量。
>
> 4位页号可以表示2<sup>4</sup> = 16个页面，和12位偏移量可以作为一页内的全部4096个字节编址。

对于虚拟内存的每个页面，可以用页号作为页表的索引，从而得出对应于该虚拟页面的页框号。如果存在的话，页框号位物理地址的高三位，再加上虚拟地址的低12位偏移量，构成了实际的15位物理地址。

**页表**

在上面也提到了，页表的目的是将虚拟页面映射成存放物理地址的页框。

> 从数学角度来看，页表是一个函数，参数是虚拟页号，结果是物理页框号。
>
> 通过这个函数可以把虚拟地址中的虚拟页面域替换为页框域。

虚拟内存的本质上是用来创造一个新的抽象概念——地址空间，是对物理内存的抽象。将虚拟内存分成多页，每一页映射到物理内存中的某个页框或者暂时解除映射。

**加速分页过程**

分页系统中需要考虑两个问题：

> 虚拟地址到物理地址的映射必须非常快。
>
> 如果虚拟地址空间过大，页表也会非常大。




内存（RAM，随机访问存储器）。

## 无存储现象

最简单的存储器抽象是根本没有抽象的。

在没有存储器抽象的系统中实现并行的一种方法是使用多线程编程。也可以通过将内存中的内容暂时存到磁盘中，读入下一个程序到内存当中。保证一个时间内内存中只有一个程序，就不会产生冲突。

## 地址空间

### 概念

地址空间是一个进程可以用于寻址内存的一套地址集合。

每一个程序都有一个自己独有的地址空间，使得一个程序对应的地址28所对应的物理地址与另一个程序中的地址28所对应的物理地址不同。

**基址寄存器与界限寄存器**

使用动态定位，将每个进程的地址空间映射到物理内存的不同部分。

经典办法通过两个特殊寄存器实现。基址寄存器用于存放程序物理地址，界限寄存器存放了程序的长度。

在每个地址送到内存之前，会自动加上基址寄存器的内容，同时也要判断地址越界问题。

> 实际中使用这个方法较慢，因为加法运算进位传递问题，在没有使用特殊电路时很慢。

### 交换技术

一个进程完整调入内存当中，但是往往一个系统需要同时运行大量的进程，如果把所有进程加载到内存当中，内存不够的情况下是做不到。

实现内存超载的技术，交换技术，虚拟内存。

**交换技术**将空闲的进程主要存储在磁盘上，当它们不运行时就不会加载到内存中。

在内存空间没有用完时，可以加载多个进程，当内存空间不够用时，将暂时不适用的进程交换到磁盘当中，腾出空间可以加载其他进程。

这样就会带来一个问题，**内存紧缩**问题

> 在我们使用上一个进程交换腾出的空间时，可能会造成多个空闲区。
>
> 可以通过将进程向下移动，有可能将这些空闲区合并，称为内存紧缩。
>
> 但是实际中我们并不这样使用，会耗费大量的CPU时间。

另一个问题是，考虑进程的数据段增长问题：

> 如果与空闲区相邻，可以直接分配。如果是和进程相邻，要交换到更大空闲区当中。否则的话只能挂载到磁盘当中，知道有足够的空闲空间使用。
>
> 考虑大多数进程在运行时数据段都会增长，在进程换入或者移动进程时分配一些**额外的内存**。
>
> 为了节省空闲区，避免交换时浪费，可以考虑两个相邻的进程，共用一段空闲区，从不同的方向进行增长。

### 空闲内存管理

针对动态分配内存，操作系统必须对其进行管理：

**位图**

将内存划分成多个分配单元，每个分配单元对应位图中一位，0表示空闲，1表示占用。

分配单元的大小是一个重要的设计问题，过小位图过大，过大会造成一定数量的内存大小浪费。

**链表**

维护一个记录已分配内存段和空闲内存端的链表。

一个链表结点或者包含一个进程，或者是两个进程间的一块空闲区。

当按照地址顺序在链表中存放进程和空闲区时，有以下的几种算法为创建的进程分配空间。

**首次适配（first fit）**

沿着段链表进行搜索，知道找到一个足够大的空闲区。一般情况下将空闲区分为供进程使用和为下一次划分的空闲区使用。

**下次适配（next fit）**

在首次适配的基础上，使用上一次划分后的空闲区，而不是重头开始找合适的空闲区。

**最佳匹配（best fit）**

搜索整个链表，从开始到结束，找出能够容纳进程的最小空间，而不是通过拆分的方法。

可以通过设置两个链表分别存放空闲区信息和进程实际存放，对空闲区进行排序，找到的第一个就是最佳适配这个进程的最小空间。

**快速适配（quick fit）**

为那些常用的空闲区维护单独的链表。

但是当一个进程使用空闲区，剩下的空闲区需要进行合并，否则无法利用小空闲区。

### 虚拟内存

交换技术带来一个问题就是，磁盘的交换速度有限，但是进程的大小在不断的增加。

虚拟内存的思路是每个程序都有自己的地址空间，每个空间被分配成多个块，每一个块被称为一页或者页面，每一页都有连续的地址范围，这些页又映射到内存当中。

但不是所有的页都要加载到内存当中。

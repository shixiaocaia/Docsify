## 虚拟内存

如果两个程序都引用相同的绝对物理地址，后一个程序会抹去前一部分的内容，所以在同一个物理地址下同时运行两个程序是行不通的。操作系统通过虚拟内存解决这个问题。

操作系统为每个进程分配独立的一套虚拟地址，并且每个进程都不能直接访问物理地址。操作系统通过将不同的进程的虚拟地址和不同的物理地址映射起来。

程序运行时先访问虚拟地址的时候，由操作系统转换为物理地址，每个虚拟地址对应不同的物理地址，避免了进程在同一个物理地址下冲突问题。

>我们程序所使用的内存地址叫做**虚拟内存地址**（*Virtual Memory Address*）
>
>实际存在硬件里面的空间地址叫**物理内存地址**（*Physical Memory Address*）

<img src="http://pic.shixiaocaia.fun/202209121946853.png" alt="img" style="zoom:50%;" />

操作系统引入了虚拟内存，进程持有的虚拟地址会通过 CPU 芯片中的**内存管理单元（MMU）**的映射关系，来转换变成物理地址，然后再通过物理地址访问内存。

> 操作系统是如何管理虚拟地址与物理地址之间的关系？

主要有两种方式，分别是**内存分段和内存分页**。

## 内存分段

程序是由若干个逻辑分段组成的，如可由代码分段、数据分段、栈段、堆段组成。**不同的段是有不同的属性的，所以就用分段（*Segmentation*）的形式把这些段分离出来。**

> 分段机制下，虚拟地址和物理地址是如何映射的？

分段机制下的虚拟地址由两部分组成，**段选择因子**和**段内偏移量**。

<img src="http://pic.shixiaocaia.fun/202209121959797.png" alt="img" style="zoom:50%;" />

CPU 芯片中的**内存管理单元**分析虚拟地址**段选择因子**和**段内偏移量**。

- 段选择因子最重要的是段号，段号是段表中的索引。段表里保存段基地址、段的界限和特权等级。

- 虚拟地址中的**段内偏移量**应该位于 0 和段界限之间，将段基地址加上段内偏移量得到物理内存地址。

虚拟地址是通过**段表**与物理地址进行映射的，分段机制会把程序的虚拟地址分成 4 个段，每个段在段表中有一个项，在这一项找到段的基地址，再加上偏移量，于是就能找到物理内存中的地址，如下图：

<img src="http://pic.shixiaocaia.fun/202209122010938.png" alt="img" style="zoom:50%;" />

**不足**

- 第一个就是**内存碎片**的问题。

操作系统在给不同进程分配内存空间时，可能造成空闲内存的不连续，即使剩余空间大于某个进程所需的内存空间，但是剩余内存空间不i按需，也无法打开新的进程。

即内存零碎的存放。可以通过内存交换，先将原本的程序占用的内存放到硬盘中，腾出连续的内存空间，然后从硬盘中再读回到内存当中。

- 第二个就是**内存交换的效率低**的问题。

上述的内存碎片问题，通过内存交换解决，如果交换的是一个占用内存空间很大的程序，就会降低效率，造成机器的卡顿。

## 内存分页


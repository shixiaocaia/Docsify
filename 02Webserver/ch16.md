## 阻塞/非阻塞、同步/异步(网络IO)

典型的一次IO的两个阶段是什么？

> 数据就绪和数据读写。

网络IO阶段1：数据就绪：根据系统IO操作的就绪状态 。主要在操作系统中进行。

- 阻塞：调用IO方法线程进入阻塞状态。
- 非阻塞：不会改变线程的状态，通过返回值判断。

网络IO阶段2：数据读写：根据应用程序和内核的交互方式。主要是在应用程序中进行。

- 同步：表示A向B请求调用一个网络IO接口时（或者调用某个业务逻辑API接口时），数据的读写都是 由请求方A自己来完成的（不管是阻塞还是非阻塞）。
- 异步：A向B请求调用一个网络IO接口时 （或者调用某个业务逻辑API接口时），向B传入请求的事件以及事件发生时通知的方式，A就可以处理其它逻辑了，当B监听到事件处理完成后，会用事先约定好的通知方式，通知A处理结果。

> 陈硕：在处理 IO 的时候，阻塞和非阻塞都是同步 IO，只有使用了特殊的 API 才是异步 IO。



## Unix/Linux上的五种IO模型

### 阻塞

调用者调用了某个函数，等待这个函数返回，期间什么也不做，不停的去检查这个函数有没有返回，必 须等这个函数返回才能进行下一步动作。

### 非阻塞

非阻塞等待，每隔一段时间就去检测IO事件是否就绪。没有就绪就可以做其他事。非阻塞I/O执行系统调 用总是立即返回，不管事件是否已经发生，若事件没有发生，则返回-1，此时可以根据 errno 区分这两
种情况，对于accept，recv 和 send，事件未发生时，errno 通常被设置成 EAGAIN。

### IO复用

Linux 用 select/poll/epoll 函数实现 IO 复用模型，这些函数也会使进程阻塞，但是和阻塞IO所不同的是这些函数可以同时阻塞多个IO操作。而且可以同时对多个读操作、写操作的IO函数进行检测。直到有数
据可读或可写时，才真正调用IO操作函数。

> 处理多个客户端的事件，不是处理高并发的事件。

### 信号驱动 

Linux 用套接口进行信号驱动 IO，安装一个信号处理函数，进程继续运行并不阻塞，当IO事件就绪，进程收到SIGIO 信号，然后处理 IO 事件。

### 异步

Linux中，可以调用 aio_read 函数告诉内核描述字缓冲区指针和缓冲区的大小、文件偏移及通知的方式，然后立即返回，当内核将数据拷贝到缓冲区后，再通知应用程序。

> 复杂，不常用。

## 服务器编程基本框架

![image-20230107161100315](http://pic.shixiaocaia.fun/202301071611871.png)

I/O 处理单元：处理客户连接，读写网络数据

逻辑单元：业务进程或线程

网络存储单元：数据库、文件或缓存

请求队列：各单元之间的通信方式

## 两种高效的事件处理模式

服务器程序通常需要处理三类事件：I/O 事件、信号及定时事件。有两种高效的事件处理模式：Reactor 和 Proactor，同步 I/O 模型通常用于实现 Reactor 模式，异步 I/O 模型通常用于实现 Proactor 模式。

### Reactor模式





### Proactor模式





## 线程池

线程池是由服务器预先创建的一组子线程，线程池中的线程数量应该和 CPU 数量差不多。线程池中的所 有子线程都运行着相同的代码。当有新的任务到来时，主线程将通过某种方式选择线程池中的某一个子线程来为之服务。

> 对比动态创建子线程代价要小很多。

- 主线程使用某种算法来主动选择子线程。
- 主线程和所有子线程通过一个共享的工作队列来同步，有相应任务时唤醒其中一个子线程来执行相应的任务。

> 线程池中线程数量与什么相关
>
> 最直接的限制因素是中央处理器(CPU)的处理器(processors/cores)的数量 N

特点：

- 空间换时间，浪费服务器的硬件资源，换取运行效率。 
- 池是一组资源的集合，这组资源在服务器启动之初就被完全创建好并初始化，这称为静态资源。 
- 当服务器进入正式运行阶段，开始处理客户请求的时候，如果它需要相关的资源，可以直接从池中 获取，无需动态分配。
- 当服务器处理完一个客户连接后，可以把相关的资源放回池中，无需执行系统调用释放资源。

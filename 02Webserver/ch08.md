## 进程间通讯

进程是一个独立的资源分配单元，不同进程（这里所说的进程通常指的是用户进程）之间 的资源是独立的，没有关联，不能在一个进程中直接访问另一个进程的资源。

但是，进程不是孤立的，不同的进程需要进行信息的交互和状态的传递等，因此需要进程 间通信( IPC：Inter Processes Communication )。

> GUI:图形用户界面
>
> IDE: 集成开发环境
>
> API: 程序之间的接口

### Linux 进程间通信的方式

<img src="http://pic.shixiaocaia.fun/202210222319525.png" alt="image-20221022231930180"  />

### 匿名管道

管道也叫无名（匿名）管道，它是是 UNIX 系统 IPC（进程间通信）的最古老形式， 所有的 UNIX 系统都支持这种通信机制。

> 管道的特点：
>
> 1. 管道其实是一个在内核内存中维护的**缓冲器**，这个缓冲器的存储能力是有限的，不同的 操作系统大小不一定相同。
>2. 管道拥有文件的特质：读操作、写操作，**匿名管道没有文件实体**，有名管道有文件实体， 但不存储数据。可以按照操作文件的方式对管道进行操作。
>    一个管道是一个字节流，使用管道时不存在消息或者消息边界的概念，从管道读取数据的进程可以读取任意大小的数据块，而不管写入进程写入管道的数据块的大小是多少。
>  3. 通过管道传递的数据是顺序的，从管道中读取出来的字节的顺序和它们被写入管道的顺序是完全一样的。
>4. 在管道中的数据的传递方向是单向的，一端用于写入，一端用于读取，管道是半双工的。 
> 5. 从管道读数据是一次性操作，数据一旦被读走，它就从管道中被抛弃，释放空间以便写 更多的数据，在管道中无法使用 lseek() 来随机的访问数据。
>6. 匿名管道只能在具有公共祖先的进程（父进程与子进程，或者两个兄弟进程，具有亲缘关系）之间使用。
> 7. 管道的数据结构是一个环形队列。

> [!NOTE]
>
> 1. 读管道
>
>    有数据， read返回实际读到的字节数无数据，
>    
>    1. 写段被全部关闭，read返回0，相当于等于文件末尾
>    2. 写端没有被全部关闭，read阻塞等待写入
>
> 2. 写管道：
>
>    管道读端全部被关闭，进程异常终止(进程收到SIGPIPE信号)
>
>    管道读端没有全部关闭：
>
>    1. 管道已满，write阻塞
>
>    2. 管道没有满，write将数据写入，并返回实际写入的字节数
>

```shell
#include <unistd.h>

int pipe(int pipefd[2]);

    func: 创建一个匿名管道，用来进程间通信。
    para: pipefd是一个传出参数
        pipefd[0]对应管道的读端
        pipefd[1]对应管道的写端
    return:
        成功 0 失败-1

    注意：匿名管道只能用于具有关系的进程之间的通信。
        管道是默认阻塞的。如果管道中没有数据，read阻塞，如果管道满了，write阻塞
```

```shell
# 修改非阻塞
设置管道非阻塞
int flags = fcntl(fd[0], F_GETFL);  // 获取原来的flag
flags |= O_NONBLOCK;            // 修改flag的值
fcntl(fd[0], F_SETFL, flags);   // 设置新的flag
```

### 有名管道

匿名管道，由于没有名字，只能用于亲缘关系的进程间通信。为了克服这个缺点，提出了有名管道（FIFO,First in First out），也叫命名管道、FIFO文件。

有名管道（FIFO）不同于匿名管道之处在于它提供了一个**路径名**与之关联，以 FIFO 的文件形式存在于文件系统中，并且其打开方式与打开一个普通文件是一样的，这样 即使与 FIFO 的创建进程不存在亲缘关系的进程，只要可以访问该路径，就能够彼此通过 FIFO 相互通信，因此，通过 FIFO 不相关的进程也能交换数据。

> 有名管道（FIFO)和匿名管道（pipe）有一些特点是相同的，不一样的地方在于：
>
> 1. FIFO 在文件系统中作为一个特殊文件存在（空的），但 FIFO 中的内容却存放在内存中。 
> 2. 当使用 FIFO 的进程退出后，FIFO 文件将继续保存在文件系统中以便以后使用。
>
> 3. FIFO 有名字，不相关的进程可以通过打开有名管道进行通信。

```cpp
命令 mkfifo name
通过函数
    #include <sys/types.h>
    #include <sys/stat.h>

    int mkfifo(const char *pathname, mode_t mode);
参数：
    pathname 管道名称的路径
    mode 文件的权限和 open的mode一样，要与u-mask与一下
    返回值：
    success 0 fail -1
```

> [!NOTE]
>
> 一个只读而打开一个管道的进程回阻塞，直到另一个进程为只写打开管道
>
> 一个只写而打开一个管道的进程会阻塞，直到另一个进程为只读打开管道
>
> 读管道：
>
> ​	管中有数据：read返回实际读到的字节数
>
> ​	管中无数据：
>
> 1. 管道写端被全部关闭，read返回0，（相当于读到文件末尾）
>
> 2. 写端没有全部被关闭，read阻塞等待
>
> 写通道：
>
> 管道读端被全部关闭，进行异常终止（收到一个SIGPIPE信号）
>
> 管道读端没有全部关闭：
>
> 1. 管道已经满了，write会阻塞
> 2. 管道没有满，write 将数据写入，并返回实际写入的字节数

### 有名通道进程对话案例

> [!NOTE]
>
> 对于chatA而言需要：
>
> 1. 判断有名管道A 和 B是否存在，如果不存在，就`mkfifo`
> 2. 以只写形式打开fifo1，以只读形式打开fifo2
> 3. 循环先通过fifo1写数据，再用fifo2读数据
>
> 对于chatB而言需要:
>
> 1. 判断有名管道A 和 B是否存在，如果不存在，就`mkfifo`
> 2. 以只读形式打开fifo1，以只写形式打开fifo2
> 3. 循环先通过fifo1读数据，再用fifo2写数据

```cpp
//chatA
#include <stdio.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <stdlib.h>
#include <fcntl.h>
#include <string.h>

int main() {

    // 1.判断有名管道文件是否存在
    int ret = access("fifo1", F_OK);
    if(ret == -1) {
        // 文件不存在
        printf("管道不存在，创建对应的有名管道\n");
        ret = mkfifo("fifo1", 0664);
        if(ret == -1) {
            perror("mkfifo");
            exit(0);
        }
    }

    ret = access("fifo2", F_OK);
    if(ret == -1) {
        // 文件不存在
        printf("管道不存在，创建对应的有名管道\n");
        ret = mkfifo("fifo2", 0664);
        if(ret == -1) {
            perror("mkfifo");
            exit(0);
        }
    }

    // 2.以只写的方式打开管道fifo1
    int fdw = open("fifo1", O_WRONLY);
    if(fdw == -1) {
        perror("open");
        exit(0);
    }
    printf("打开管道fifo1成功，等待写入...\n");
    // 3.以只读的方式打开管道fifo2
    int fdr = open("fifo2", O_RDONLY);
    if(fdr == -1) {
        perror("open");
        exit(0);
    }
    printf("打开管道fifo2成功，等待读取...\n");

    char buf[128];

    // 4.循环的写读数据
    while(1) {
        memset(buf, 0, 128);
        // 获取标准输入的数据
        fgets(buf, 128, stdin);
        // 写数据
        ret = write(fdw, buf, strlen(buf));
        if(ret == -1) {
            perror("write");
            exit(0);
        }

        // 5.读管道数据
        memset(buf, 0, 128);
        ret = read(fdr, buf, 128);
        if(ret <= 0) {
            perror("read");
            break;
        }
        printf("buf: %s\n", buf);
    }

    // 6.关闭文件描述符
    close(fdr);
    close(fdw);

    return 0;
}
```

```cpp
//chatB
#include <stdio.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <stdlib.h>
#include <fcntl.h>
#include <string.h>

int main() {

    // 1.判断有名管道文件是否存在
    int ret = access("fifo1", F_OK);
    if(ret == -1) {
        // 文件不存在
        printf("管道不存在，创建对应的有名管道\n");
        ret = mkfifo("fifo1", 0664);
        if(ret == -1) {
            perror("mkfifo");
            exit(0);
        }
    }

    ret = access("fifo2", F_OK);
    if(ret == -1) {
        // 文件不存在
        printf("管道不存在，创建对应的有名管道\n");
        ret = mkfifo("fifo2", 0664);
        if(ret == -1) {
            perror("mkfifo");
            exit(0);
        }
    }

    // 2.以只读的方式打开管道fifo1
    int fdr = open("fifo1", O_RDONLY);
    if(fdr == -1) {
        perror("open");
        exit(0);
    }
    printf("打开管道fifo1成功，等待读取...\n");
    // 3.以只写的方式打开管道fifo2
    int fdw = open("fifo2", O_WRONLY);
    if(fdw == -1) {
        perror("open");
        exit(0);
    }
    printf("打开管道fifo2成功，等待写入...\n");

    char buf[128];

    // 4.循环的读写数据
    while(1) {
        // 5.读管道数据
        memset(buf, 0, 128);
        ret = read(fdr, buf, 128);
        if(ret <= 0) {
            perror("read");
            break;
        }
        printf("buf: %s\n", buf);

        memset(buf, 0, 128);
        // 获取标准输入的数据
        fgets(buf, 128, stdin);
        // 写数据
        ret = write(fdw, buf, strlen(buf));
        if(ret == -1) {
            perror("write");
            exit(0);
        }
    }

    // 6.关闭文件描述符
    close(fdr);
    close(fdw);

    return 0;
}
```

### 内存映射

内存映射（Memory-mapped I/O）是将磁盘文件的数据映射到内存，用户通过修改 内存就能修改磁盘文件。

不同进程映射同一文件，进行修改。

> [!使用内存映射关系实现进程间通信]
>
> 1. 实现有关系（父子）进程的通信
>    1. 还没有子进程时候，通过唯一的父进程，先创建内存映射区
>    2. 有了内存映射区后，创建子进程
>    3. 父子进程共享内存映射区
> 2. 没有关系的进程通信
>    1. 准备一个大小不为0的磁盘文件
>    2. 进程1 通过磁盘文件创建内存映射区，得到一个操作这块内存的指针
>    3. 进程2 通过磁盘文件创建内存映射区，得到一个操作这块内存的指针
>    4. 使用内存映射区通信
> 3. 注意内存映射区通信是非阻塞的。

```cpp
//1
#include <stdio.h>
#include <sys/mman.h>
#include <fcntl.h>
#include <sys/types.h>
#include <unistd.h>
#include <string.h>
#include <stdlib.h>
#include <wait.h>
int main(){
    //1. open the file,get its length
    int fd = open("test.txt", O_RDWR);
    int size = lseek(fd, 0, SEEK_END);

    //2. build mmaping
    void *ptr = mmap(NULL, size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
    if(ptr == MAP_FAILED){
        perror("mmap");
        exit(0);
    }
    //3. 创建子进程
    pid_t pid = fork();
    if(pid > 0){
        wait(NULL); //回收子进程，再去读取数据
        char buf[64];
        strcpy(buf, (char *)ptr);
        printf("read data: %s\n", buf);
    }
    else if(pid == 0){
        strcpy((char *)ptr, "nihao a, son!!!");
    }

    munmap(ptr, size);

    return 0;
}
```

> 果对mmap的返回值(ptr)做++操作(ptr++),munmap是否能够成功？
>
> A:能操作，但是释放会错误，必须是首地址
>
> 如果open时O_RDONLY,mmap时prot参数指定PROT_READ I PROT_WRITE会怎样？
>
> A：返回MAP_FAILED，权限不想符
>
> 如果文件偏移量为1000会怎样？
>
> A：偏移量必须是4k的整数倍，返回MAP_FAILED
>
> mmap什么情况下会调用失败？
>
> A：length = 0，port权限不够
>
> 可以open的时候O CREAT一个新文件来创建映射区吗？
>
> A：可以，但是创建的文件大小需要扩展，lseek，truncate
>
> mmap后关闭文件描述符，对mmap映射有没有影响？
>
> A：映射区还存在，创建fd被关闭，没有影响

> 可以做文件拷贝。

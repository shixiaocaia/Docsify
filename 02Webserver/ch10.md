## 网络通信过程

![网络通信的过程](http://pic.shixiaocaia.fun/202212101426713.png ':size=70%')

### 从发送方看

**应用层**

程序在数据的前面加上**协议头**，传输信息nihao。

**传输层**

选择UDP进行传输。

src ip源端口号，dst ip目的端口号。

**网络层**

使用IP协议形成IP数据报，其中重要的源端、目的端的IP地址。

**数据链路层**

增加以太网帧的协议。主要增加了源和目的MAC地址，type类型。

---

### 从接收方看

**数据链路层**

根据头部的以太网帧的MAC地址，判断是不是对应的目的主机，是的话进行解封装（去除以太网帧信息），交付给上层。

**网络层**

根据IP数据报信息，看目的IP地址是否是本身，不是会丢弃，同样进行解封装。

**传输层**

根据端口号进行解析。

**应用层**

根据端口号找到对应的进程。

### ARP请求

![arp请求封装](http://pic.shixiaocaia.fun/202212101426467.png ':size=70%')

> 在不知道目的主机信息时，通过ARP协议，查找IP地址对应的MAC地址。（RARP协议是MAC地址找对应的IP地址）`arp -a`
>
> 处于数据链路层的协议，要加以太网帧。

A发送一个ARP请求，在这样一个局域网内机器，都能收到相应的信息。每个机器根据对应的目的IP地址判断是不是自己。

一般情况都是在应用层使用下层的报，API。

## socket介绍

- 所谓 socket（套接字），就是对网络中不同主机上的应用进程之间进行双向通信的端点的抽象。
- socket是网络环境中进程间通信的API。
- socket 本身有“插座”的意思，在 Linux 环境下，用于表示进程间网络通信的特殊文件类型。本质为内核借助缓冲区形成的伪文件。

> 是直接使用的API，不需要关注底层的实现。
>
> 套接字通信分两部分： 
>
> - 服务器端：被动接受连接，一般不会主动发起连接 
> - 客户端：主动向服务器发起连接
>
> socket是一套通信的接口，Linux 和 Windows 都有，但是有一些细微的差别。

### 字节序

大于一个字节类型的数据在内存中的存放顺序。

字节序分为大端字节序（Big-Endian）和小端字节序（Little-Endian）。 

- 大端字节序是指一个整数的最高位字节 （23~31bit）存储在内存的低地址处， 低位字节 （0~7bit）存储在内存的高地址处； 
- 小端字节序则是指整数的高位字节存储在内存的高地址处， 而低位字节则存储在内存的低地址处。

一般计算机采用小端字节序，要保证字节序的统一。

> 网络字节顺序是 TCP/IP 中规定好的一种数据表示格式，它与具体的 CPU 类型、操作系统等无关，从而 可以保证数据在不同主机之间传输时能够被正确解释，网络字节顺序采用大端排序方式。
>
> BSD Socket提供了封装好的转换接口，方便程序员使用。包括从主机字节序到网络字节序的转换函数： htons、htonl；从网络字节序到主机字节序的转换函数：ntohs、ntohl。

**字节转换函数**

```c
h  - host 主机，主机字节序
to - 转换成什么 n
n  - network 网络字节序
s  - short unsigned short
l  - long  unsigned int
    
#include <arpa/inet.h>
// 转换端口 2个字节
uint16_t htons(uint16_t hostshort); //主机字节序－网络字节序
uint16_t ntohs(uint16_t netshort);  //主机字节序－网络字节序
// 转IP 4个字节long
uint32_t htonl(uint32-t hostlong);  //主机字节序－网络字节序
uint32_t ntohl(uint32_tnetlong);    //主机字节序－网络字节序
```

> 每个字节 8位 2进制。

### 地址

> // socket地址其实是一个结构体，封装端口号和IP等信息。后面的socket相关的api中需要使用到这个 socket地址。
> // 客户端 -> 服务器（IP, Port）

**通用socket地址**

```c
#include <bits/socket.h> 
struct sockaddr { 
	sa_family_t sa_family; 
    char sa_data[14];
};
typedef unsigned short int sa_family_t;
```

> sa_family 成员是地址族类型（sa_family_t）的变量。
>
> sa_data 成员用于存放 socket 地址值。

**专用socket地址**

很多网络编程函数诞生早于 IPv4 协议，那时候都使用的是 struct sockaddr 结构体，为了向前兼容，现 在sockaddr 退化成了（void *）的作用，传递一个地址给函数，至于这个函数是 sockaddr_in 还是
sockaddr_in6，由地址族确定，然后函数内部再强制类型转化为所需的地址类型。

> 所有专用 socket 地址（以及 sockaddr_storage）类型的变量在实际使用时都需要转化为通用 socket 地 址类型 sockaddr（强制转化即可），因为所有 socket 编程接口使用的地址参数类型都是 sockaddr。

### IP地址转换

> 字符串ip-整数 ，主机、网络 字节序的转换。

通常，人们习惯用可读性好的字符串来表示 IP 地址，比如用点分十进制字符串表示 IPv4 地址，以及用 十六进制字符串表示 IPv6 地址。但编程中我们需要先把它们转化为整数（二进制数）方能使用。而记录日志时则相反，我们要把整数表示的 IP 地址转化为可读的字符串。

```c
    #include <arpa/inet.h>
    // p:点分十进制的IP字符串，n:表示network，网络字节序的整数
    int inet_pton(int af, const char *src, void *dst);
        af:地址族： AF_INET  AF_INET6
        src:需要转换的点分十进制的IP字符串
        dst:转换后的结果保存在这个里面

    // 将网络字节序的整数，转换成点分十进制的IP地址字符串
    const char *inet_ntop(int af, const void *src, char *dst, socklen_t size);
        af:地址族： AF_INET  AF_INET6
        src: 要转换的ip的整数的地址
        dst: 转换成IP地址字符串保存的地方
        size：第三个参数的大小（数组的大小）
        返回值：返回转换后的数据的地址（字符串），和 dst 是一样的
```

## TCP通信流程

![image-20221216153328494](http://pic.shixiaocaia.fun/202212161533325.png)

![](http://pic.shixiaocaia.fun/202212161535801.png ':size=50%')


> // TCP 通信的流程
>
> // 服务器端 （被动接受连接的角色） 
>
> 1. 创建一个用于监听的套接字 
>    - 监听：监听有客户端的连接 
>    - 套接字：这个套接字其实就是一个文件描述符
>
> 2. 将这个监听文件描述符和本地的IP和端口绑定（IP和端口就是服务器的地址信息） 
>    - 客户端连接服务器的时候使用的就是这个IP和端口
> 3. 设置监听，监听的fd开始工作 
> 4. 阻塞等待，当有客户端发起连接，解除阻塞，接受客户端的连接，会得到一个和客户端通信的套接字 （fd）
> 5. 通信
>    - 接收数据 
>    - 送数据
> 6. 通信结束，断开连接

> // 客户端
>
> 1. 创建一个用于通信的套接字（fd）
> 2. 连接服务器，需要指定连接的服务器的 IP 和 端口
> 3. 连接成功了，客户端可以直接和服务器通信
>    - 接收数据 
>    - 发送数据
>
> 4. 通信结束，断开连接

### socket套接字

```c
#include <sys/types.h>
#include <sys/socket.h>
#include<arpa/inet.h>//包含了这个头文件，上面两个就可以省略
int socket(int domain,int type,int protocol);
	-功能：创建一个套接字
	-参数：
		-domain:协议族
            AF_INET ipv4
            AF_INET6 ipv6
            AF_UNIX,AF_LOCAL:本地套接字通信（进程间通信）
                
		-type:通信过程中使用的协议类型
			SOCK_STREAM:流式协议
			SOCK_DGRAM:报式协议
                
		-protoco1:具体的一个协议。一般写0
			SOCK_STREAM:流式协议默认使用TCP
                
		-SOCK DGRAM:报式协议默认使用UDP
		-返回值：
			-成功：返回文件描述符，操作的就是内核缓冲区。
			-失败：-1

int bind(int sockfd,const struct sockaddr *addr,socklen_t addrlen);//socket命名

	-功能：绑定，将fd和本地的IP+端口进行绑定
	-参数：
        -sockfd:通过socket函数得到的文件描述符
        -addr:需要绑定的socket.地址，这个地址封装了ip和端口号的信息
        -addrlen:第二个参数结构体占的内存大小
            
int listen(int sockfd,int backlog);///proc/sys/net/core/somaxconn
    -功能：监听这个socket上的连接
    -参数：
    	-sockfd:通过socket（）函数得到的文件描述符
    	-back1og：未连接的和己经连接的和的最大值，一般设置为5
            
int accept(int sockfd,struct sockaddr *addr,socklen_t *addrlen);
    -功能：接收客户端连接，默认是一个阻塞的函数，阻塞等待客户端连接
    -参数：
        -sockfd：用于监听的文件描述符
        -addr:传出参数，记录了连接成功后客户端的地址信息(ip,port)
        -addrlen:指定第二个参数的对应的内存大小
    -返回值：
        - 成功：用于通信的文件描述符
        - -1：失败
            
int connect(int sockfd,const struct sockaddr *addr,socklen_t addrlen);
    功能：
    	客户端连接服务器
    -参数：
    	-sockfd:用于通信的文件描述符
    	-addr：客户端要连接的服务器的地址信息
    	-addrlen:第二个参数的内存大小
    -返回值：成功0，失败-1
            
ssize_t write(int fd,const void*buf,size_t count);//写数据
ssize_t read(int fd,void *buf,size_t count);
//读数据
```

### C/S实现



### TCP通信并发

要实现TCP通信服务器处理并发的任务，使用多线程成者多进程来解决。

思路：

1. 一个父进程，多个子进程。
2. 父进程：负责等待并接受客户端的连接。
3. 子进程：完成通信，接受一个客户端连接，就创健一个子进程用于通信。

> 对父进程中accept要进行错误处理，软中断处理子进程回收问题后，直接回收错误了。

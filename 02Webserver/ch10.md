## 网络通信过程

![网络通信的过程](http://pic.shixiaocaia.fun/202212101426713.png)

### 从发送方看

**应用层**

程序在数据的前面加上**协议头**，传输信息nihao。

**传输层**

选择UDP进行传输。

src ip源端口号，dst ip目的端口号。

**网络层**

使用IP协议形成IP数据报，其中重要的源端、目的端的IP地址。

**数据链路层**

增加以太网帧的协议。主要增加了源和目的MAC地址，type类型。

---

### 从接收方看

**数据链路层**

根据头部的以太网帧的MAC地址，判断是不是对应的目的主机，是的话进行解封装（去除以太网帧信息），交付给上层。

**网络层**

根据IP数据报信息，看目的IP地址是否是本身，不是会丢弃，同样进行解封装。

**传输层**

根据端口号进行解析。

**应用层**

根据端口号找到对应的进程。

### ARP请求

![arp请求封装](http://pic.shixiaocaia.fun/202212101426467.png)

> 在不知道目的主机信息时，通过ARP协议，查找IP地址对应的MAC地址。（RARP协议是MAC地址找对应的IP地址）`arp -a`
>
> 处于数据链路层的协议，要加以太网帧。

A发送一个ARP请求，在这样一个局域网内机器，都能收到相应的信息。每个机器根据对应的目的IP地址判断是不是自己。

一般情况都是在应用层使用下层的报，API。

## socket介绍

- 所谓 socket（套接字），就是对网络中不同主机上的应用进程之间进行双向通信的端点的抽象。
- socket是网络环境中进程间通信的API。
- socket 本身有“插座”的意思，在 Linux 环境下，用于表示进程间网络通信的特殊文件类型。本质为内核借助缓冲区形成的伪文件。

> 是直接使用的API，不需要关注底层的实现。
>
> 套接字通信分两部分： 
>
> - 服务器端：被动接受连接，一般不会主动发起连接 
> - 客户端：主动向服务器发起连接
> 
> socket是一套通信的接口，Linux 和 Windows 都有，但是有一些细微的差别。

### 字节序

大于一个字节类型的数据在内存中的存放顺序。

字节序分为大端字节序（Big-Endian）和小端字节序（Little-Endian）。 

- 大端字节序是指一个整数的最高位字节 （23~31bit）存储在内存的低地址处， 低位字节 （0~7bit）存储在内存的高地址处； 
- 小端字节序则是指整数的高位字节存储在内存的高地址处， 而低位字节则存储在内存的低地址处。

一般计算机采用小端字节序，要保证字节序的统一。

> 网络字节顺序是 TCP/IP 中规定好的一种数据表示格式，它与具体的 CPU 类型、操作系统等无关，从而 可以保证数据在不同主机之间传输时能够被正确解释，网络字节顺序采用大端排序方式。
>
> BSD Socket提供了封装好的转换接口，方便程序员使用。包括从主机字节序到网络字节序的转换函数： htons、htonl；从网络字节序到主机字节序的转换函数：ntohs、ntohl。

**字节转换函数**

```c
h  - host 主机，主机字节序
to - 转换成什么 n
n  - network 网络字节序
s  - short unsigned short
l  - long  unsigned int
    
#include <arpa/inet.h>
// 转换端口 2个字节
uint16_t htons(uint16_t hostshort); //主机字节序－网络字节序
uint16_t ntohs(uint16_t netshort);  //主机字节序－网络字节序
// 转IP 4个字节long
uint32_t htonl(uint32-t hostlong);  //主机字节序－网络字节序
uint32_t ntohl(uint32_tnetlong);    //主机字节序－网络字节序
```

> 每个字节 8位 2进制。

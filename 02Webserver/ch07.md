## exec 函数族

一系列功能相似或者相同的函数。

函数族的作用是根据指定的文件名找到可执行文件，并用它来取代调用进程的 内容，换句话说，就是在调用进程内部执行一个可执行文件。

> 实际当中，我们先fork一个子进程，然后再子进程中运行exec。
>
> exec 函数族的函数执行成功后不会返回，因为调用进程的实体，包括代码段，数据 段和堆栈等都已经被新的内容取代。
>
> 只有调用失败才会返回 -1。

### execl函数

```shell
#include <unistd.h>

int execl(const char *path, const char *arg, ...)

    - 参数：
    	- path: 需要指定的执行的文件的路径或者名称
        a.out /home/nowcoder/a.out 推荐使用绝对路径。

    - arg: 是可执行文件所需要的参数列表
    	第一个参数一般没有什么作用，为了方便，一般写的是执行的程序的名称
    	第二个参数开始往后，就是程序执行所需要的参数列表
    	参数最后需要以NULL结束（哨兵）
    - 返回值
    	仅仅只有出错时返回-1.并设置errno。
    	成功没有返回值。
```

### execlp函数

```shell
#include <unistd.h>

int execlp(const char *file, const char *arg,  ...)
- 会到环境变量中查找指定的可执行文件，如果找到了就执行，找不到就执行不成功
- 参数：
	- file: 需要执行的可执行文件的文件名
	a.out 

- arg: 是可执行文件所需要的参数列表
    第一个参数一般没有什么作用，为了方便，一般写的是执行的程序的名称
    第二个参数开始往后，就是程序执行所需要的参数列表
    参数最后需要以NULL结束（哨兵）
- 返回值
	仅仅只有出错时返回-1.并设置errno。
	成功没有返回值。
```

## exit _exit

```shell
#include <stdlib.h>

void exit(int status);

参数：是进程退出时一个状态信息。父进程回收子进程时候可以捕获


---------------------

#include <unistd.h>

void _exit(int status);
```

> 二者的区别，主要在于退出时是否刷新缓冲区。

## 孤儿进程

当父进程结束后，子进程未结束，这样的子进程就称为孤儿进程 （Orphan Process）。

孤儿进程将会被 进程号 1 终端 领养。

孤儿进程没有什么危害。

## 僵尸进程

每个进程结束之后, 都会释放自己地址空间中的用户区数据，内核区的 PCB 没有办法 自己释放掉，需要父进程去释放。

进程终止时，父进程尚未回收，子进程残留资源（PCB）存放于内核中，变成僵尸 （Zombie）进程。

僵尸进程不能被 kill -9 杀死，这样就会导致一个问题，如果父进程不调用 wait() 或 waitpid() 的话，那么保留的那段信息就不会释放，其进程号就会一直被占用， 但是系统所能使用的进程号是有限的，如果大量的产生僵尸进程，**将因为没有可用的进程号而导致系统不能产生新的进程，此即为僵尸进程的危害，应当避免。**

> 当父进程杀死时，子进程变成孤儿进程，被进程号为1的托管，最终释放。

## wait waitpid

父进程可以通过调用wait或waitpid得到它的退出状态同时彻底清除掉这个进程。

wait() 和 waitpid() 函数的功能一样，区别在于，wait() 函数会阻塞， waitpid() 可以设置不阻塞，waitpid() 还可以指定等待哪个子进程结束。

> 阻塞：wait要等待子进程结束，否则会造成阻塞,等待子进程结束。

一次wait或waitpid调用只能清理一个子进程，清理多个子进程应使用循环。

```cpp
//wait
       #include <sys/types.h>
       #include <sys/wait.h>

       pid_t wait(int *wstatus);
       
       func: 等待任意一个子进程结束，如果任意一个子进程结束了，函数会回收子进程的状态信息
       para: 进程退出时的状态信息，传入的是一个int类型的地址，传出参数。
       return value: 返回被回收的子进程ID，失败-1(所有进程结束，或调用失败)

       调用wait函数的进程会被挂起（阻塞），知道它的一个子进程退出，或者收到一个不能被忽略的信号时才被唤醒，继续向下执行

       如果没有子进程了，会立即返回，返回-1，回收资源
```

```cpp
//waitpid
#include <sys/types.h>
#include <sys/wait.h>

pid_t waitpid(pid_t pid, int *wstatus, int options);

func: 回收指定进程好的子进程，可以设置是否阻碍
para: 
    pid:
        < -1 回收某个进程组的组id的绝对值，回收指定进程组的子进程
        -1  回收所有的子进程（其他组的子进程
        0   回收当前进程组的所有子进程
        > 0 某个子进程的pid
    wastatus：进程退出时的状态信息，传入的是一个int类型的地址，传出参数。
    options: 
        0:阻塞
        WNOHANG:非阻塞
    返回值：
        > 0 返回子进程的id
        = 0 options = WNOHANG 表示还有子进程
        = -1 错误，或者没有子进程了
```


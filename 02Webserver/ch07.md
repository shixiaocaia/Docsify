## exec 函数族

一系列功能相似或者相同的函数。

函数族的作用是根据指定的文件名找到可执行文件，并用它来取代调用进程的 内容，换句话说，就是在调用进程内部执行一个可执行文件。

> 实际当中，我们先fork一个子进程，然后再子进程中运行exec。
>
> exec 函数族的函数执行成功后不会返回，因为调用进程的实体，包括代码段，数据 段和堆栈等都已经被新的内容取代。
>
> 只有调用失败才会返回 -1。

### execl函数

```shell
#include <unistd.h>

int execl(const char *path, const char *arg, ...)

    - 参数：
    	- path: 需要指定的执行的文件的路径或者名称
        a.out /home/nowcoder/a.out 推荐使用绝对路径。

    - arg: 是可执行文件所需要的参数列表
    	第一个参数一般没有什么作用，为了方便，一般写的是执行的程序的名称
    	第二个参数开始往后，就是程序执行所需要的参数列表
    	参数最后需要以NULL结束（哨兵）
    - 返回值
    	仅仅只有出错时返回-1.并设置errno。
    	成功没有返回值。
```

### execlp函数

```shell
#include <unistd.h>

int execlp(const char *file, const char *arg,  ...)
- 会到环境变量中查找指定的可执行文件，如果找到了就执行，找不到就执行不成功
- 参数：
	- file: 需要执行的可执行文件的文件名
	a.out 

- arg: 是可执行文件所需要的参数列表
    第一个参数一般没有什么作用，为了方便，一般写的是执行的程序的名称
    第二个参数开始往后，就是程序执行所需要的参数列表
    参数最后需要以NULL结束（哨兵）
- 返回值
	仅仅只有出错时返回-1.并设置errno。
	成功没有返回值。
```

## exit _exit

```shell
#include <stdlib.h>

void exit(int status);

参数：是进程退出时一个状态信息。父进程回收子进程时候可以捕获


---------------------

#include <unistd.h>

void _exit(int status);
```

> 二者的区别，主要在于退出时是否刷新缓冲区。

## 孤儿进程

当父进程结束后，子进程未结束，这样的子进程就称为孤儿进程 （Orphan Process）。

孤儿进程将会被 进程号 1 终端 领养。

孤儿进程没有什么危害。

## 僵尸进程

每个进程结束之后, 都会释放自己地址空间中的用户区数据，内核区的 PCB 没有办法 自己释放掉，需要父进程去释放。

进程终止时，父进程尚未回收，子进程残留资源（PCB）存放于内核中，变成僵尸 （Zombie）进程。

僵尸进程不能被 kill -9 杀死，这样就会导致一个问题，如果父进程不调用 wait() 或 waitpid() 的话，那么保留的那段信息就不会释放，其进程号就会一直被占用， 但是系统所能使用的进程号是有限的，如果大量的产生僵尸进程，**将因为没有可用的进程号而导致系统不能产生新的进程，此即为僵尸进程的危害，应当避免。**

> 当父进程杀死时，子进程变成孤儿进程，被进程号为1的托管，最终释放。

## wait waitpid

父进程可以通过调用wait或waitpid得到它的退出状态同时彻底清除掉这个进程。

wait() 和 waitpid() 函数的功能一样，区别在于，wait() 函数会阻塞， waitpid() 可以设置不阻塞，waitpid() 还可以指定等待哪个子进程结束。

> 阻塞：wait要等待子进程结束，否则会造成阻塞。

一次wait或waitpid调用只能清理一个子进程，清理多个子进程应使用循环。

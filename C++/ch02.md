## 内联函数

**define的缺陷**

- 预定义宏函数没有作用域概念，无法作为一个类的成员函数，也就是说预定义宏没有办法表示类的范围。
- 没有类型检查，不安全。

**inline**

- 增加关键字inline, 代替宏。
- 内联函数用空间换时间（节省了压栈、跳转和返回的时间，没有普通函数调用时的额外开销）
- 内联函数是一个特殊的函数，会进行类型检查；
- 是对编译器的一种请求，编译器有可能拒绝这种请求。
- C++中inline的限制，不存在任何形式的循环语句，不能存在过多的条件判断语句，函数体不能过大，内联函数声明必须在调用语句之前。

```cpp
#define ADD(x,y) x+y
inline int Add(int x,int y){
	return x + y;
}
void test(){
	int ret1 = ADD(10, 20) * 10; //希望的结果是300
	int ret2 = Add(10, 20) * 10; //希望结果也是300
	cout << "ret1:" << ret1 << endl; //210
	cout << "ret2:" << ret2 << endl; //300
}
```

class 中成员函数默认加inline关键字（编译器优化），以下特殊情况，即使加了inline**也不会**进行内联编译处理。

- 不能存在任何形式的循环语句

- 不能存在过多的条件判断语句

- 函数体不能过于庞大
- 不能对函数进行取址操作

> 函数若在class body内定义完成，便自动成为inline候选人，不代表百分百成为inline函数，注意上述的情况。 

## 函数参数

**默认参数**

声明带默认参数，实现不需要。

```cpp
void TestFunc01(int a = 10, int b = 20){
	cout << "a + b  = " << a + b << endl;
}
```

**占位参数**

区分前置和后置递增运算符的重载。

```cpp
Complex& operator++(Complex& p) //前置
Complex& operator++(int) //后置
```

## 函数重写（override)

以实现不同的功能，一般适用于子类在继承父类时，重写父类方法。

规则：

1. 重写方法的参数列表，返回值，所抛出的异常与重写方法一致。
2. 被重写的方法不能为private。
3. 静态方法不能被重写为非静态的方法。
4. 重写的方法的访问修饰符一定要大于被重写方法的访问修饰符（pubilc>protected>default>private)。

## 函数重载(overload)

在c中是允许出现**同名**的函数，这种现象称为函数重载。

条件：1. 必须在同一个作用域下。2. 函数的参数个数、类型、顺序不同。

注意：1. 函数返回值不可以作为判断重载的条件。2. 函数重载和默认参数之间注意二义性问题。 3. 实际上编译器是将函数重载进行了重命名进行区分。

## extern “C”浅析

- c函数: void MyFunc(){} , 被编译成函数: MyFunc

- c函数: void MyFunc(){}, 被编译成函数: _Z6Myfuncv
- 使用extern "C" void show(), show方法按照C语言方式做链接

## c语言下的封装和C++下的封装

C++中的封装 严格类型转换检测，让属性和行为绑定一起。C语言中struct只能定义属性，不能定义函数。

C++中类的权限：public, protected , private

struct 默认权限是 public，class默认权限是private，私有只能在类的内部访问。protected 保护权限，类的内部访问，外部不可以访问，类的子类可以访问。

一般情况将class所有成员熟悉设置为private，通过public间接的读和写。

## 构造函数和析构函数

```cpp
#include"chead"
class Person {
public:
	Person() {
		cout << "构造函数(普通、无参)的调用" << endl;
	}
	Person(int a) {
		cout << "构造函数(普通、有参)的调用" << endl;
		age = a;
	}

	//根据类型又分为上面的普通和拷贝
	Person(const Person& p) {
		age = p.age;
		cout << "构造函数(拷贝、有参)的调用,使用另一个对象初始化本对象" << endl;
	}

	//析构函数
	~Person() {
		cout<<"析构函数的调用" << endl;
	}

	int age;
};

void test01() {
	//
	Person p1(1);//有参构造函数调用
	p1.age = 10;
	Person p2(p1);//拷贝构造函数调用，p2.age = 10;

	Person p3; //无参构造函数调用，不要加(),加()当作了函数声明

	Person p4 = Person(100); //显示调用 等价于有参调用
	Person p5 = Person(p5); //显示调用 拷贝构造函数

	Person(100); //匿名对象，编译对象发现对象是匿名，运行话此行后就会被释放。

	Person(p5); //不能用拷贝构造函数 初始化匿名对象，被当作了对象声明，重定义

}
```

## 深拷贝和浅拷贝

同一类型的对象之间可以赋值，使得两个对象的成员变量的值（地址）相同，两个对象仍然是独立的两个对象，这种情况被称为**浅拷贝**。浅拷贝后，可能会导致两次释放堆区空间，导致挂掉。

解决：使用自建的拷贝构造函数，进行**深拷贝**，指向不同的堆区，避免重复的释放。

## 初始化列表

```cpp
/*Person(int a, int b, int c) {
		m_A = a;
		m_B = b;
		m_C = c;
	}*/

//初始化列表方式，构造函数后面增加 属性（值，参数），属性（值，参数）
//无参
Person() :m_A(10), m_B(11), m_C(12) {
}
//有参
Person(int a, int b, int c) : m_A(a), m_B(b), m_C(c) {
}
```

## 隐式类型转换

```cpp
class People 
{ 
public: 
    int age; 
    People (int a)  {  age=a;  } 
};

void foo ( void ) 
{   
    People p1(10);  //方式一  
    People* p_p2=new People(10); //方式二  
    People p3=10; //方式三 
}
```

该例中，方式一和方式二都是平时编程过程中常用到的对象定义方式，而方式三即是特殊的方式，因为C/C++是一种强类型语言，不同的数据类型是不能随意转换的，如果要进行类型转换，必须进行显示强制类型转换，而这里，没有进行任何显示的转换，直接将一个整形数据赋值给类类变量p3。
因此，可以说，方式三中进行了一次隐式类型转换，编译器自动将对应于构造函数参数类型的数据转换为了该类的对象，因此方式三经编译器自动转换后和方式一最终的实现方式是一样的。

## explicit关键字

explicit关键字的作用就是禁止隐式转换这个特性，如文章一开始而言，凡是用explicit关键字修饰的构造函数，编译时就不会进行自动转换，而会报错。如下例所示：

```cpp
class A
{               
    A(int a);     
};  

int Function(A a);
```

当调用Function(2)的时候，2会隐式转换为A类型。这种情况常常不是程序员想要的结果，所以，要避免之，就可以这样写：

```cpp
class A
{               
    explicit A(int a);     
};  

int Function(A a);
```

这样，当调用`Function(2)`的时候，编译器会给出错误信息（除非Function有个以int为参数的重载形式），这就避免了在程序员毫不知情的情况下出现错误。

## new运算符使用

代替c语言 malloc动态分配类型，是在堆区开辟空间。

| new          | malloc      |
| -----------  | ----------- |
| 返回该类型的指针| 返回void\*指针,并且需要强转    |
| 调用构造      | 不调用构造        |
| delete释放| free释放|
|是一个运算符| 是一个函数|

- 无法释放`void *p = new Person` 构造的指针。

- 通过new开辟数组，**一定会调用默认构造函数，所以一定要提供默认构造函数。在自定义有参构造函数后，系统不会默认提供，要手动添加。**

- 注：`Person p[2] = {Person(1), Person(2)}`开辟空间是在栈区，是可以指定开的。

- 释放数组要中括号，告知有多个对象需要释放。`delete [] p;`这样才能调用多次的析构函数，否则只调用一次析构函数，造成内存的泄露。

> new：先分配memory，再调用ctor（构造）
>
> delete：先调用dtor（析构），再释放memory


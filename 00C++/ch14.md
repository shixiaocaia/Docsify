## 拷贝、赋值与销毁

### 拷贝

**拷贝初始化以下情况使用**

> 1. 定义变量时。
> 2. 将一个对象作为实参传递给一个非引用类型的形参。
> 3. 从一个返回类型为非引用类型的函数返回一个对象。
> 4. 用花括号列表初始化一个数组中的元素或一个聚合类中的成员。
>
> 因此我们拷贝构造函数自己的参数应该是引用类型，否则无法调用成功：为了调用拷贝构造函数，我们必须拷贝它的实参，但为了拷贝实参，我们又需要调用拷贝构造函数，如此无限循环。

### 重载赋值运算符

赋值运算符通常应该返回一个指向其左侧运算对象的引用。

> [!NOTE]
>
> 为什么有的函数返回值是引用类型？
>
> 通过使用引用来替代指针，会使 C++ 程序更容易阅读和维护。C++ 函数可以返回一个引用，方式与返回一个指针类似。
>
> 当函数返回一个引用时，则返回一个指向返回值的隐式指针。这样，函数就可以放在赋值语句的左边。

### 析构

析构函数是用来释放内存资源，销毁非静态数据成员。

当一个类没有定义析构函数时，编译器会为他合成析构函数。

由于析构函数不接受参数，不能被重载。

**什么时候发生自动调用析构函数**

> 1. 变量离开其作用域时被销毁。
>
> 2. 当一个对象被销毁时，其成员被销毁。
> 3. 容器被销毁时，其元素被销毁。
> 4. 对于动态分配的对象，当对指向它的指针应用delete运算符被销毁时。
> 5. 对于临时对象，当创建它的完整表达式结束时被销毁。

> 合成析构函数并不直接销毁成员，成员是在析构函数体之后隐含的析构阶段中被销毁的。

**对于成员指针**

手动释放，避免析构结束后，指针消失，但是内存依旧存在造成内存泄漏的问题。

对于在构造函数中分配动态内存的，析构函数应该手写一个释放构造函数分配的动态内存。

> [!NOTE]
>
> 内存泄漏和内存的重复释放都是大错误。
>
> 重复释放可能造成二次分配的内存被错误释放掉。

**需要析构函数的类也需要拷贝和赋值操作**

> 当一个类需要定义自己版本的析构函数的时候，一般就是在类对象的创建过程中使用了动态内存。
>
> 一旦使用了动态内存，就会涉及深浅拷贝的问题。
>
> 我们知道，默认拷贝构造函数执行的是浅拷贝，这就会引起一份内存被释放两次，会出错。
>
> 因此，我们会就需要定义自己版本的构造函数和赋值运算符！

**使用=default**

```cpp
Sales_data = default;
```

我们可以通过将拷贝控制成员定义为=default来显式地要求编译器生成合成的版本。

当我们在类内用=default修饰成员的声明时，合成的函数将隐式地声明为**内联**的（就像任何其他类内声明的成员函数一样）。如果我们不希望合成的成员是内联函数，应该只对成员的类外定义使用=default,就像对拷贝赋值运算符所做的那样。

### 阻止拷贝

> [!NOTE]
>
> 大多数类应该定义拷贝和构造函数，但是对于一些类是没有意义的。
>
> 在此情况下，定义类时需要采用某种机制组织拷贝和赋值。

**定义删除函数**

在函数的参数列表后面加上 `= delete`来指出我们希望将它定义为删除。

```cpp
strcut NoCopy {
    NoCopy() = default;
    NoCopy(const NoCopy&) = delete; // 阻止拷贝
    NoCopy &operator=(const NoCopy&) = delete; //阻止析构
    ~NoCopy() = default;
}
```

我们可以对任何函数指定`=delete`，而`=default`只能对合成的默认构造函数和拷贝控制成员使用。

**private拷贝控制**

在新标准发布之前，类是通过将其拷贝构造函数和拷贝赋值运算符声明为private的来阻止拷贝。

通过声明private的拷贝构造函数，但不定义，预先阻止任何拷贝该类型对象的企图。

## 拷贝控制和资源管理

管理类外资源的类必须定义拷贝控制成员。

可以定义拷贝操作，使之像一个值或者像一个指针。

类的行为像一个**值**，意味着它应该也有自己的状态。当我们拷贝一个像值的对象时，副本和原对象是完全独立的。改变副本不会对原对象有任何影响，反之亦然。

行为像**指针**的类则共享状态。当我们拷贝一个这种类的对象时，副本和原对象使用相同的底层数据。改变副本也会改变原对象，反之亦然。

### 行为像值的类

### 行为像指针的类

通过**引用计数**来直接管理资源。

> 1. 通过构造函数分配新的计数器，计数器置为1。
> 2. 拷贝构造函数拷贝成员，递增计数器，递增右侧计数器，递减左侧计数器，在必要时析构。
> 3. 析构函数根据计数器为0判断是否释放内存。

## 移动构造函数

通过使用新标准库引入的两种机制，避免string的拷贝，提高性能。

移动构造函数通常是将资源从给定对象移动而不是拷贝到正在创建的对象，而且我们知道标准库保证“移后源” string仍然保持一个有效的、可析构的状态。

第二个机制是，使用名为`move`的标准库函数，定义在utility头文件当中。

## 对象移动

有时候拷贝是不必要，直接进行移动效率比较高。

### 右值引用

右值引用必须绑定到右值的引用，我们通过&& 而不是 & 来获得右值引用。

> 右值引用只能绑定到一个将要销毁的对象，因此可以自由地移动其资源。
>
> 左值引用也就是常规的引用，不能绑定到要转换的表达式、字面常量或返回右值的表达式。

一般而言，一个左值表达式表示一个对象的身份，而一个右值表达式表示的是对象的值。

```cpp
int i = 42;
int &r = i; // r 引用 i 

int &&rr = i; // error不能将一个右值引用绑定到一个左值上
int &r2 = i * 42; // error i * 42是一个右值
const int &r3 = i * 42; //将一个cosnst的引用绑定到一个右值上
int &&rr2 = i * 42; //将rr2绑定到乘法结果上
```

**左值持久；右值短暂**

左值有持久的状态，而右值要么是字面常量，要么是再表达式求值过程中创建的临时对象。

由于右值引用只能绑定到临时对象，我们得知

- 所引用的对象将要被销毁
- 该对象没有其他用户

右值引用的代码可以自由地接管所引用的对象的资源。

**变量是左值**

因此我们不能将一个右值引用直接绑定到一个变量上，即使变量是右值引用类型也不行。

```cpp
int &&rr1 = 42; //右值引用
int &&rr2 = rr1; //error
```

**标准库move函数**

通过将左值转换为对应的右值引用类型。

通过调用一个move的新标准库函数，来获得绑定到左值的右值引用。

```cpp
int &&rr3 = std::move(rr1); //success
```

使用`std::move`而不是move，这可以避免潜在的名字冲突。


## 不熟悉的概念

**在类定义中的类成员函数实现有文件内部作用域，而在类定义外部的类实现有的是全局作用域。**

> 类实例化出的对象中只保存成员变量，成员函数存放在公共的区域。
>
> 如果采用这种存储方法，每个对象的成员变量不同，代表各自独立的信息，而调用的函数是一样的，可以尽可能的节省空间。这也是实际的存储方式。

**for(auto) 处理多维数组时，除了最内层的循环以外，其他所有循环的控制变量都应该是引用类型。**

> 如果不是引用类型，编译器会错误初始化数据类型。

**读懂指针类型**

```cpp
int *ip[4]; //整型指针的数组
int (*ip)[4]; //指向含有4个整数的数组，(*ip)先说明他是个指针，指向4个元素的数组，然后类型是int类型
```

## 标注

### C++ primer第四章的类型转换

#### 算术转换

运算符的运算对象将转换成最宽的类型。

#### 隐式类型转换

常见的几种：

数组自动转换为指向数组首元素的指针；

常量整数值 0 或者字面值 nullptr 能转换为任意指针类型；

算术类型向指针类型向布尔类型的自动转换。

#### 显式转换

```cpp
int i,j;
double slope = i/j;
```

> 上面这种强制转换实际上是危险的。
>
> 我们应该尽量避免使用强制转换，哪怕是下面的几种新形式。

在C++中我们使用的强制转换格式是`cast-name<type>(expression)`,cast-name是以下中的多种中的一种。

type是要转化的类型，expression是待转换的值。

**static_cast**

用于任何具有明确定义的类型转换，只要不好含底层的const（用const_cast)。

用于找回存放于void* 指针中的值。

```cpp
double slope = static_cast<double>(j) / i;
```

**dynamic_cast**

```cpp
dynamic_cast < type-id > ( expression)
```


该运算符把expression转换成type-id类型的对象。Type-id可以是类的指针、类的引用或者void*。如果type-id是类指针类型，那么expression也必须是一个指针，如果type-id是一个引用，那么expression也必须是一个引用。

作用: 将一个基类对象指针（或引用）cast到继承类指针，dynamic_cast会根据基类指针是否真正指向继承类指针来做相应处理， 即会作出一定的判断。
若对指针进行dynamic_cast，失败返回null，成功返回正常cast后的对象指针；
若对引用进行dynamic_cast，失败抛出一个异常，成功返回正常cast后的对象引用。

**reinterpret_cast**

通常为运算对象的位模式提供较低层次上的重新解释。

> [!note]使用此强制转换，是一件非常危险的事。

**const_cast**

只能改变运算对象的底层const。

将常量对象转换为非常量对象的行为，必须是常量对象。

常常用于有函数重载的上下文当中。

### 返回类型和return语句


## 模糊概念

**在类定义中的类成员函数实现有文件内部作用域，而在类定义外部的类实现有的是全局作用域。**

> 类实例化出的对象中只保存成员变量，成员函数存放在公共的区域。
>
> 如果采用这种存储方法，每个对象的成员变量不同，代表各自独立的信息，而调用的函数是一样的，可以尽可能的节省空间。这也是实际的存储方式。

**for(auto) 处理多维数组时，除了最内层的循环以外，其他所有循环的控制变量都应该是引用类型。**

> 如果不是引用类型，编译器会错误初始化数据类型。

**读懂指针类型**

```cpp
int *ip[4]; //整型指针的数组
int (*ip)[4]; //指向含有4个整数的数组，(*ip)先说明他是个指针，指向4个元素的数组，然后类型是int类型
```

**引用传递**

在做到LC.332，这边的回溯递归时，如果我的形参既不是全局变量，也不是引入传递的话，在回溯过程中传递的是子函数作用域下的数值，在此作用域结束时就被消除了，使用引入的方式，是直接对数组进行修改。

**作用域问题**

```cpp
Screen::pos Screen::size() const
{
    return height * width;
}
```

`Screen::pos` 是因为返回类型pos本身定义在Screen类当中，所以类的外部不可以直接使用pos。

`size()`这个函数是Screen的成员函数，在类外定义，要加作用域。

**" :: "符号**

```cpp
auto pItem = :: find(c.begin(), c.end(), target);
//表明所使用的算法是全局的函数模板函数，如果没有这个编译器找不到方案
```

## C++多文件编程

稍微大一点的项目都不会是单个文件的，多文件的好处实在太多，模块开发、分工协作、代码复用、结构清晰、模块更新…

cpp程序一般分为三类文件：
  - 头文件( .h )。放置各种声明，用于被cpp文件包含。
  - 模块文件（.cpp）。放置一些函数定义，也称为功能模块。
  - 主程序文件（.cpp）。包含main()的文件，程序入口，调用模块文件实现的方法。

**头文件**

C++编译过程原理：C++把每个文件单独编译出来，再通过链接把编译出来的多个文件组成一个可执行程序。

为了解决使用其他文件的函数时重复繁琐的声明，将所有声明类的语句放到一个文件里，称为头文件。头文件的内容会在编译前被粘贴到源文件中，这样在编译的时候就能正常通过了。

此外，头文件的内容一般都会使用条件编译预处理语句（如上）包住，防止因为依赖关系多次被包含。

```cpp
#ifndef HEADER_H
#define HEADER_H
void fun();
#endif
```

头文件中常包含以下内容：

- 函数声明
- 类定义、结构定义：用函数定义的逻辑想，似乎不能放在头文件中。但它应该放在头文件。第一，每个cpp文件应该有一个定义，在编译的时候编译器才知道怎么为对象分配空间。其次，类型定义不会在内存上分配空间。
- 模板函数：编译器必须在编译的时候根据函数模板实例化对应的函数，所以应该放在头文件。
- 内联函数：编译期间被插到调用位置，所以也要放在头文件。
- **函数定义：不要！**C++规定一个程序同签名的函数只能有一个定义。如果你把函数定义放在头文件件，并且同一个程序的多个cpp文件包含了该头文件，这样，在链接的时候会发现多个定义版本，链接报错。
- **变量定义：不要！**与上面类似，被多个文件包含的时候会出现多次定义同一个变量，链接错误。但是，static变量和extern变量可以，以及宏定义的常量，因为这些在多个文件出现并不会出错。

**源文件**

除去头文件，剩下的内容可以放在源文件中，常分类模块文件和主程序文件。

**多文件编译**

如果是使用Windows下的集成开发环境的，大可直接Build，一键搞定，但你对这个过程的理解就可能差点。所以我以linux上为例，最简单的多文件编译命令：

```cpp
g++ main.cpp fun.cpp -o out   #列举所有要编译的文件
```

也可以单独编译成 .o文件之后再链接：

```cpp
g++ -c main.cpp -o main.o
g++ -c fun.cpp -o fun.o
g++ main.o fun.o -o out
```

第二种相对麻烦，但是提供了一个优点——模块编译更新。你只需要编译你修改过的文件，再跟其他的链接，无需再次对整个项目编译。

在实际的项目中，项目文件可不是小数目，无论上面的那种方式，你都需要一一列出文件，不实际。IDE工具自然没有这种烦恼。不过Linux也会使用Makefile进行项目管理，实现自动编译。

## 区分“.”和“->”

```cpp
class student{
public:
    string name;
}

student *xy; //*xy是对象(结构体），所以可以这样写
(*xy).name ="123"; //同样等价为xy->name = "123"; 指针用->

student xy;
xy.name = "123";//普通类的成员属性访问 对象用点

```

> student *xy;
>
> (*xy),name, 由于解运算符的优先级别低于点运算符的优先级。如果不加括号，xy本身是一个指针，他没有name这个成员，必须加解运算符。

## 读懂C++类型声明

**步骤：**

- 第一步，找到变量名，如果没有变量名，找到最里面的结构
- 第二步，向右看，读出你看到的东西，但是不要跳过括号
- 第三步，再向左看，读出你看到的东西，但是也不要跳过括号
- 第四步，如果有括号的话，跳出一层括号，从内到外，从右到左
- 第五步，重复上述过程，直到你读出最终的类型

**例子**

```cpp
int *v[5];
1. 找到变量名v
2. 向右看，尺寸为5的数组  
3. 右边没有了，向左看，是个指针，指向int
v是一个有5个指向int类型的指针的数组——指针的数组

int (*v)[5];
1. 找到变量名v
2. 向右看，有一个括号，不能跳过，是一个指针
3. 向右看，指向数组
3. 右边没有了，向左看，指向int
v是个指向有5个整数的数组的指针。——数组的指针
```
```cpp
int func();
//func是一个返回int的函数

int (*func)();
//func是一个指针，是一个函数，返回值是int型，所以func是一个指针，返回一个int型的函数，即函数指针。

int (*V[])();
// v是一个数组，数组内每个元素是指针，每个指针指向一个函数，返回值是int。整体看，v是一个int型函数指针组成的数组。
```

```cpp
int const a;
const int a;
// a的值不可变。

int const *r;
// r 向左看，是一个指针，所以r是一个指向const int的指针，*r不可变，但是r本身不是const，所以可以将r指向其他地址，地址内的内容不可变

int *const r;
// r是一个const，r是一个const类型的指针，r本身的值不可变，int类型不是const，所以*r内容可以改变，指向的地址不可变，地址内容可变
```

## 栈、堆和内存管理

**stack**

存在于某作用域的一块内存空间。例如调用函数，函数本身会形成一块stack用来放置接受的参数，返回值。包括了函数体内声明的任何变量。

离开作用域会自动释放。一般这种创建的object，我们称之为auto object。

当我们加了static 关键词，变量称之为static object，直到程序结束才被消除。

global object 全局变量，定义在main函数之外，直到程序结束。

**heap**

操作系统提供的一块global内存空间，程序可以动态分配若干区域。当然你申请就需要自己销掉。

### 几种object类型

离开作用域会自动释放。一般这种创建的object，我们称之为auto object。

当我们加了static 关键词，变量称之为static object，直到程序结束才被消除。

global objects 全局变量，定义在main函数之外，直到程序结束。

heap objects 声明周期在deleted之前。在作用域之外，没有delete将造成内存泄漏。

### 内存管理

  ![image-20220925090726739](http://pic.shixiaocaia.fun/202209250907017.png)

首先我们观察最左侧，最上方和最下方是cookie，灰色的是调式自带的部分，不同的编译器可能有不同的大小，然后complex类型占用2连个double，8个字节，最后由于内存块的大小是16的倍数，52不满大小，再补3个块，构成64，多余的部分在后面会有一定的作用。

左边数第二个，是非调式情况下，只有一个cookie + 变量占用，cookie能告知计算机需要回收多大的分配空间。41，末尾的0和1表示分配和回收。

动态分配数组时，会多一个位置存放数组的大小。

## 转换函数

![在这里插入图片描述](http://pic.shixiaocaia.fun/202209281409534.png)

这里程序中写了一个将Fraction类型转为double类型的转换函数，由于转换函数后续声明了类型，返回值不需要类型。

```cpp
double d = 4 + f;
```

这一句实际上进行了如下判断:

1. 首先是在查找有无符号“+”的重载函数，发现没有
2. 然后再尝试寻找转换函数，发现4和f都有对应的转化函数，于是执行转换。

## Non-explicit one argument constructor

![在这里插入图片描述](http://pic.shixiaocaia.fun/202209281417134.png)

编译器查找有没有关于符号"+"的重载，发现找到了，但是符号所需要的参数不对，应该是一个const Fraction& 类型，而这里是一个int类型，于是编译器试图对齐进行一个类型转换，由于类Fraction的构造函数仅需要一个int类型的参数，所以这里由于4满足条件，所以类Fraction的构造函数将其隐式转换成了Fraction类型的对象来执行了这个操作。

**转换函数与Non-explicit one argument constructor同时存在时，会发生冲突**

由此引入，在有参构造函数的函数名前加入`explict`关键词，能够解决冲突问题。

## 智能指针

![image-20220928202546254](http://pic.shixiaocaia.fun/202209282025613.png)

当创建一个实例时，默认构造函数进行初始化，将指针赋予给私有指针px。

## 关于迭代器

![image-20220928203522457](http://pic.shixiaocaia.fun/202209282035769.png)

## 仿函数

![image-20220928205819975](http://pic.shixiaocaia.fun/202209282058292.png)

标准中有很多仿函数，是一个个小的类，每一个都重载了小括号，并且会继承一些大的父类。

## 类型转换

#### 算术转换

运算符的运算对象将转换成最宽的类型。

#### 隐式类型转换

常见的几种：

数组自动转换为指向数组首元素的指针；

常量整数值 0 或者字面值 nullptr 能转换为任意指针类型；

算术类型向指针类型向布尔类型的自动转换。

#### 显式转换

```cpp
int i,j;
double slope = i/j;
```

> 上面这种强制转换实际上是危险的。
>
> 我们应该尽量避免使用强制转换，哪怕是下面的几种新形式。

在C++中我们使用的强制转换格式是`cast-name<type>(expression)`,cast-name是以下中的多种中的一种。

type是要转化的类型，expression是待转换的值。

**static_cast**

用于任何具有明确定义的类型转换，只要不好含底层的const（用const_cast)。

用于找回存放于void* 指针中的值。

```cpp
double slope = static_cast<double>(j) / i;
```

**dynamic_cast**

```cpp
dynamic_cast < type-id > ( expression)
```


该运算符把expression转换成type-id类型的对象。Type-id可以是类的指针、类的引用或者void*。如果type-id是类指针类型，那么expression也必须是一个指针，如果type-id是一个引用，那么expression也必须是一个引用。

作用: 将一个基类对象指针（或引用）cast到继承类指针，dynamic_cast会根据基类指针是否真正指向继承类指针来做相应处理， 即会作出一定的判断。
若对指针进行dynamic_cast，失败返回null，成功返回正常cast后的对象指针；
若对引用进行dynamic_cast，失败抛出一个异常，成功返回正常cast后的对象引用。

**reinterpret_cast**

通常为运算对象的位模式提供较低层次上的重新解释。

> 使用此强制转换，是一件非常危险的事。

**const_cast**

只能改变运算对象的底层const。

将常量对象转换为非常量对象的行为，必须是常量对象。

常常用于有函数重载的上下文当中。

